<!DOCTYPE html>


<html class="writer-html5" lang="en" >
<!-- Copyright (C) 2020-2022, Marek Gagolewski <https://www.gagolewski.com> -->

<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>8. Processing Multidimensional Data &mdash; Minimalist Data Wrangling with Python by Marek Gagolewski</title>
  

  
  
  <script async defer src="https://buttons.github.io/buttons.js"></script>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/proof.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  
    <link rel="canonical" href="https://datawranglingpy.gagolewski.com/chapter/320-transform-matrix.html" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/proof.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="9. Exploring Relationships Between Variables" href="330-relationship.html" />
    <link rel="prev" title="7. Multidimensional Numeric Data at a Glance" href="310-matrix.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html"> Minimalist Data Wrangling with Python [v1.0.0]
          

          
          </a>

          <div class="version">
          An open-access textbook<br />
          by <a style="color: inherit" href="https://www.gagolewski.com">Marek Gagolewski</a>
          </div>

<!--
          
            
            
              <div class="version">
                by Marek Gagolewski
              </div>
            
          
-->

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search phrase..." />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Start Here</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="000-preface.html">Preface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introducing Python</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="110-setup.html">1. Getting Started with Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="120-scalar.html">2. Scalar Types and Control Structures in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="130-sequential.html">3. Sequential and Other Types in Python</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Unidimensional Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="210-vector.html">4. Unidimensional Numeric Data and Their Empirical Distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="220-transform-vector.html">5. Processing Unidimensional Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="230-distribution.html">6. Continuous Probability Distributions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Multidimensional Data</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="310-matrix.html">7. Multidimensional Numeric Data at a Glance</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. Processing Multidimensional Data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#from-vectors-to-matrices">8.1. From Vectors to Matrices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vectorised-mathematical-functions">8.1.1. Vectorised Mathematical Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#componentwise-aggregation">8.1.2. Componentwise Aggregation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arithmetic-logical-and-comparison-operations">8.1.3. Arithmetic, Logical, and Comparison Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#matrix-vs-scalar">8.1.3.1. Matrix vs Scalar</a></li>
<li class="toctree-l4"><a class="reference internal" href="#matrix-vs-matrix">8.1.3.2. Matrix vs Matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="#matrix-vs-any-vector">8.1.3.3. Matrix vs Any Vector</a></li>
<li class="toctree-l4"><a class="reference internal" href="#row-vector-vs-column-vector">8.1.3.4. Row Vector vs Column Vector (*)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#other-row-and-column-transforms">8.1.4. Other Row and Column Transforms (*)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#indexing-matrices">8.2. Indexing Matrices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#slice-based-indexing">8.2.1. Slice-Based Indexing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scalar-based-indexing">8.2.2. Scalar-Based Indexing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-boolean-integer-vector-and-scalar-slice-indexers">8.2.3. Mixed Boolean/Integer Vector and Scalar/Slice Indexers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#two-vectors-as-indexers">8.2.4. Two Vectors as Indexers (*)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#views-on-existing-arrays">8.2.5. Views on Existing Arrays (*)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-and-modifying-rows-and-columns">8.2.6. Adding and Modifying Rows and Columns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#matrix-multiplication-dot-products-and-the-euclidean-norm">8.3. Matrix Multiplication, Dot Products, and the Euclidean Norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pairwise-distances-and-related-methods">8.4. Pairwise Distances and Related Methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-euclidean-metric">8.4.1. The Euclidean Metric</a></li>
<li class="toctree-l3"><a class="reference internal" href="#centroids">8.4.2. Centroids</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multidimensional-dispersion-and-other-aggregates">8.4.3. Multidimensional Dispersion and Other Aggregates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fixed-radius-and-k-nearest-neighbour-search">8.4.4. Fixed-Radius and <em>K</em>-Nearest Neighbour Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spatial-search-with-k-d-trees">8.4.5. Spatial Search with <em>K</em>-d Trees</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">8.5. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="330-relationship.html">9. Exploring Relationships Between Variables</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Heterogeneous Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="410-data-frame.html">10. Introducing Data Frames</a></li>
<li class="toctree-l1"><a class="reference internal" href="420-categorical.html">11. Handling Categorical Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="430-group-by.html">12. Processing Data in Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="440-sql.html">13. Accessing Databases</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Data Types</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="510-text.html">14. Text Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="520-missingness.html">15. Missing, Censored, and Questionable Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="530-time-series.html">16. Time Series</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="998-changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="999-bibliography.html">Bibliography</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://datawranglingpy.gagolewski.com/datawranglingpy.pdf">This Book in PDF</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/datawranglingpy/blob/master/CODE_OF_CONDUCT.md">Report Bugs or Typos</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/teaching_data">Datasets</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.gagolewski.com">Author</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Minimalist Data Wrangling with Python [v1.0.0]</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          



















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">8. </span>Processing Multidimensional Data</li>
    
    
      <li class="wy-breadcrumbs-aside">

        
        
        <a class="github-button" href="https://github.com/gagolews/datawranglingpy" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star gagolews/datawranglingpy on GitHub">Star</a>
        


        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="330-relationship.html" class="btn btn-neutral float-right" title="9. Exploring Relationships Between Variables" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      
      
        <a href="310-matrix.html" class="btn btn-neutral float-left" title="7. Multidimensional Numeric Data at a Glance" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section class="tex2jax_ignore mathjax_ignore" id="processing-multidimensional-data">
<span id="chap-transform-matrix"></span><h1><span class="section-number">8. </span>Processing Multidimensional Data<a class="headerlink" href="#processing-multidimensional-data" title="Permalink to this heading"></a></h1>
<blockquote>
<div><p><em>The online version of the open-access textbook</em> Minimalist Data
Wrangling with Python <em>by <a class="reference external" href="https://www.gagolewski.com">Marek Gagolewski</a>
is, and will remain, freely available for everyone’s enjoyment
(also in <a class="reference external" href="https://datawranglingpy.gagolewski.com/datawranglingpy.pdf">PDF</a>).
Any <a class="reference external" href="https://github.com/gagolews/datawranglingpy/blob/master/CODE_OF_CONDUCT.md">bug/typos reports/fixes</a>
are appreciated. Although available online, this is a whole course;
it should be read from the beginning to the end.
Refer to the <a class="reference internal" href="000-preface.html#chap-preface"><span class="std std-ref">Preface</span></a> for general introductory remarks.</em></p>
</div></blockquote>
<section id="from-vectors-to-matrices">
<h2><span class="section-number">8.1. </span>From Vectors to Matrices<a class="headerlink" href="#from-vectors-to-matrices" title="Permalink to this heading"></a></h2>
<p>Let us study how the vector operations that we discussed in, amongst others,
<a class="reference internal" href="220-transform-vector.html#chap-transform-vector"><span class="std std-numref">Chapter 5</span></a> can be extended to matrices.
In many cases, we will end up applying the same transform either
on every matrix element separately, or on each row or column.
They are all brilliant examples of the <em>write less, do more</em> principle
in practice.</p>
<section id="vectorised-mathematical-functions">
<h3><span class="section-number">8.1.1. </span>Vectorised Mathematical Functions<a class="headerlink" href="#vectorised-mathematical-functions" title="Permalink to this heading"></a></h3>
<p>Applying vectorised functions such
as <strong class="command">numpy.round</strong>, <strong class="command">numpy.log</strong>, and <strong class="command">numpy.exp</strong>
returns an array of the same shape, with all elements
transformed accordingly.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="p">])</span>  <span class="c1"># example matrix that we will be using below</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="c1">## array([[0.04, 0.36, 0.16, 0.16],</span>
<span class="c1">##        [0.  , 0.04, 0.16, 0.49],</span>
<span class="c1">##        [0.64, 0.64, 0.04, 0.01]])</span>
</pre></div>
</div>
<p>takes the square of every element.</p>
<p>More generally, we will be denoting such operations with:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
f(\mathbf{X})=
\left[
\begin{array}{cccc}
f(x_{1,1}) &amp; f(x_{1,2}) &amp; \cdots &amp; f(x_{1,m}) \\
f(x_{2,1}) &amp; f(x_{2,2}) &amp; \cdots &amp; f(x_{2,m}) \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
f(x_{n,1}) &amp; f(x_{n,2}) &amp; \cdots &amp; f(x_{n,m}) \\
\end{array}
\right].
\end{split}\]</div>
</section>
<section id="componentwise-aggregation">
<h3><span class="section-number">8.1.2. </span>Componentwise Aggregation<a class="headerlink" href="#componentwise-aggregation" title="Permalink to this heading"></a></h3>
<p>Unidimensional aggregation functions
(e.g., <strong class="command">numpy.mean</strong>, <strong class="command">numpy.quantile</strong>)
can be applied to summarise:</p>
<ul class="simple">
<li><p>all data into a single number (<code class="docutils literal notranslate"><span class="pre">axis=None</span></code>, being the default),</p></li>
<li><p>data in each column (<code class="docutils literal notranslate"><span class="pre">axis=0</span></code>), as well as</p></li>
<li><p>data in each row (<code class="docutils literal notranslate"><span class="pre">axis=1</span></code>).</p></li>
</ul>
<p>Here are the examples corresponding to the above cases:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="c1">## 0.39999999999999997</span>
<span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">## array([0.33333333, 0.53333333, 0.33333333, 0.4       ])</span>
<span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([0.4  , 0.325, 0.475])</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Let us repeat, <code class="docutils literal notranslate"><span class="pre">axis=1</span></code> does not mean
that we get the column means (even though
columns constitute the 2nd axis, and we count starting at 0).
It denotes the axis <em>along</em> which the matrix is sliced.
Sadly, even yours truly sometimes does not get it right
on the first attempt.</p>
</div>
<div class="proof proof-type-exercise" id="id9">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.1</span>
        
    </div><div class="proof-content">
<p>Given the <a class="reference external" href="https://raw.githubusercontent.com/gagolews/teaching_data/master/marek/nhanes_adult_female_bmx_2020.csv"><code class="docutils literal notranslate"><span class="pre">nhanes_adult_female_bmx_2020</span></code></a>
dataset, compute the mean, standard deviation, minimum,
and maximum of each body measurement.</p>
</div></div><p>We will get back to the topic of the aggregation of
multidimensional data in <a class="reference internal" href="#sec-distances"><span class="std std-numref">Section 8.4</span></a>.</p>
</section>
<section id="arithmetic-logical-and-comparison-operations">
<h3><span class="section-number">8.1.3. </span>Arithmetic, Logical, and Comparison Operations<a class="headerlink" href="#arithmetic-logical-and-comparison-operations" title="Permalink to this heading"></a></h3>
<p>Recall that for vectors, binary operators
such as `<strong class="command">+</strong>`, `<strong class="command">*</strong>`, `<strong class="command">==</strong>`,
`<strong class="command">&lt;=</strong>`, and `<strong class="command">&amp;</strong>`
as well as similar elementwise functions (e.g., <strong class="command">numpy.minimum</strong>)
can be applied if both inputs are of the same length,
for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>  <span class="c1"># elementwisely</span>
<span class="c1">## array([   7,  -60,  200, 8000])</span>
</pre></div>
</div>
<p>Alternatively, one input can be a scalar:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">])</span> <span class="o">*</span> <span class="o">-</span><span class="mi">3</span>
<span class="c1">## array([   -3,   -30,  -300, -3000])</span>
</pre></div>
</div>
<p>More generally, a set of rules referred to in the
<strong class="program">numpy</strong> manual as
<a class="reference external" href="https://numpy.org/devdocs/user/basics.broadcasting.html"><em>broadcasting</em></a>
describes how this package handles arrays of different shapes.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Generally, for two matrices, their column/row numbers much match
or be equal to 1.
Also, if one operand is a one-dimensional array, it will be promoted
to a row vector.</p>
</div>
<p>Let us explore all the possible scenarios.</p>
<section id="matrix-vs-scalar">
<h4><span class="section-number">8.1.3.1. </span>Matrix vs Scalar<a class="headerlink" href="#matrix-vs-scalar" title="Permalink to this heading"></a></h4>
<p>If one operand is a scalar, then it is going to be propagated
over all matrix elements, for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">A</span>
<span class="c1">## array([[-0.2, -0.6, -0.4, -0.4],</span>
<span class="c1">##        [-0. , -0.2, -0.4, -0.7],</span>
<span class="c1">##        [-0.8, -0.8, -0.2, -0.1]])</span>
</pre></div>
</div>
<p>changes the sign of every element, which is,
mathematically,
an instance of multiplying a matrix <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> by a scalar <span class="math notranslate nohighlight">\(c\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
c\mathbf{X}=
\left[
\begin{array}{cccc}
cx_{1,1} &amp; cx_{1,2} &amp; \cdots &amp; cx_{1,m} \\
cx_{2,1} &amp; cx_{2,2} &amp; \cdots &amp; cx_{2,m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
cx_{n,1} &amp; cx_{n,2} &amp; \cdots &amp; cx_{n,m} \\
\end{array}
\right].
\end{split}\]</div>
<p>Furthermore:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="o">**</span><span class="mi">2</span>
<span class="c1">## array([[0.04, 0.36, 0.16, 0.16],</span>
<span class="c1">##        [0.  , 0.04, 0.16, 0.49],</span>
<span class="c1">##        [0.64, 0.64, 0.04, 0.01]])</span>
</pre></div>
</div>
<p>takes the square<a class="footnote-reference brackets" href="#footsquare" id="id1">1</a> of each element.
Also:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">&gt;=</span> <span class="mf">0.25</span>
<span class="c1">## array([[False,  True,  True,  True],</span>
<span class="c1">##        [False, False,  True,  True],</span>
<span class="c1">##        [ True,  True, False, False]])</span>
</pre></div>
</div>
<p>compares each element to 0.25.</p>
</section>
<section id="matrix-vs-matrix">
<h4><span class="section-number">8.1.3.2. </span>Matrix vs Matrix<a class="headerlink" href="#matrix-vs-matrix" title="Permalink to this heading"></a></h4>
<p>For two matrices of identical sizes, we act
on the <em>corresponding</em> elements:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># just an example</span>
<span class="n">B</span>  <span class="c1"># a lower triangular 0-1 matrix</span>
<span class="c1">## array([[1., 0., 0., 0.],</span>
<span class="c1">##        [1., 1., 0., 0.],</span>
<span class="c1">##        [1., 1., 1., 0.]])</span>
</pre></div>
</div>
<p>And now:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">*</span> <span class="n">B</span>
<span class="c1">## array([[0.2, 0. , 0. , 0. ],</span>
<span class="c1">##        [0. , 0.2, 0. , 0. ],</span>
<span class="c1">##        [0.8, 0.8, 0.2, 0. ]])</span>
</pre></div>
</div>
<p>multiplies each <span class="math notranslate nohighlight">\(a_{i,j}\)</span> by the corresponding <span class="math notranslate nohighlight">\(b_{i,j}\)</span>.</p>
<p>This extends on the idea from algebra that given
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> with <em>n</em> rows and <em>m</em> columns each,
the result of <span class="math notranslate nohighlight">\(+\)</span> (or <span class="math notranslate nohighlight">\(-\)</span>) would be for instance:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{A} + \mathbf{B}=
\left[
\begin{array}{cccc}
a_{1,1}+b_{1,1} &amp; a_{1,2}+b_{1,2} &amp; \cdots &amp; a_{1,m}+b_{1,m} \\
a_{2,1}+b_{2,1} &amp; a_{2,2}+b_{2,2} &amp; \cdots &amp; a_{2,m}+b_{2,m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{n,1}+b_{n,1} &amp; a_{n,2}+b_{n,2} &amp; \cdots &amp; a_{n,m}+b_{n,m} \\
\end{array}
\right].
\end{split}\]</div>
<p>Thanks to the matrix-matrix and matrix-scalar operations
we can perform various tests on a per-element basis, e.g.,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;=</span> <span class="mf">0.25</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A</span> <span class="o">&lt;=</span> <span class="mf">0.75</span><span class="p">)</span>  <span class="c1"># logical matrix &amp; logical matrix</span>
<span class="c1">## array([[False,  True,  True,  True],</span>
<span class="c1">##        [False, False,  True,  True],</span>
<span class="c1">##        [False, False, False, False]])</span>
</pre></div>
</div>
<div class="proof proof-type-example" id="id10">

    <div class="proof-title">
        <span class="proof-type">Example 8.2</span>
        
    </div><div class="proof-content">
<p>(*)
<a class="reference internal" href="#fig-ex-contourf"><span class="std std-numref">Figure 8.1</span></a> depicts a (filled) contour plot
of the Himmelblau’s function, <span class="math notranslate nohighlight">\(f(x,y)=(x^{2}+y-11)^{2}+(x+y^{2}-7)^{2}\)</span>,
for <span class="math notranslate nohighlight">\(x\in[-5, 5]\)</span> and <span class="math notranslate nohighlight">\(y\in[-4, 4]\)</span>.
To draw it, we probed 250 points from the two said
ranges and called <strong class="command">numpy.meshgrid</strong> to generate
two matrices, both of shape 250 by 250,
giving the x- and y-coordinates of all the points on
the corresponding two-dimensional grid.
Thanks to this, we were able to use vectorised mathematical operations
to compute the values of <span class="math notranslate nohighlight">\(f\)</span> thereon.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="n">xg</span><span class="p">,</span> <span class="n">yg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">xg</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yg</span> <span class="o">-</span> <span class="mi">11</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">xg</span> <span class="o">+</span> <span class="n">yg</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">CS</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">250</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clabel</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default" id="id11">
<span id="fig-ex-contourf"></span><img alt="../_images/ex-contourf-1.png" src="../_images/ex-contourf-1.png" />
<figcaption>
<p><span class="caption-number">Figure 8.1 </span><span class="caption-text">An example filled contour plot with additional labelled contour lines</span><a class="headerlink" href="#id11" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>To understand the result generated by
<strong class="command">numpy.meshgrid</strong>, here is its output for a smaller number
of probe points:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">xg</span><span class="p">,</span> <span class="n">yg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">xg</span>
<span class="c1">## array([[-5.,  0.,  5.],</span>
<span class="c1">##        [-5.,  0.,  5.],</span>
<span class="c1">##        [-5.,  0.,  5.],</span>
<span class="c1">##        [-5.,  0.,  5.],</span>
<span class="c1">##        [-5.,  0.,  5.]])</span>
</pre></div>
</div>
<p>Here, each column is the same.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">yg</span>
<span class="c1">## array([[-4., -4., -4.],</span>
<span class="c1">##        [-2., -2., -2.],</span>
<span class="c1">##        [ 0.,  0.,  0.],</span>
<span class="c1">##        [ 2.,  2.,  2.],</span>
<span class="c1">##        [ 4.,  4.,  4.]])</span>
</pre></div>
</div>
<p>In this case, each row is identical. Thanks to this, calling:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">xg</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yg</span> <span class="o">-</span> <span class="mi">11</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">xg</span> <span class="o">+</span> <span class="n">yg</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="c1">## array([[116., 306., 296.],</span>
<span class="c1">##        [208., 178., 148.],</span>
<span class="c1">##        [340., 170., 200.],</span>
<span class="c1">##        [320.,  90., 260.],</span>
<span class="c1">##        [340., 130., 520.]])</span>
</pre></div>
</div>
<p>gives a matrix <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> such that
<span class="math notranslate nohighlight">\(z_{i,j}\)</span> is generated by considering the <span class="math notranslate nohighlight">\(i\)</span>-th element in <code class="docutils literal notranslate"><span class="pre">y</span></code>
and the <span class="math notranslate nohighlight">\(j\)</span>-th item in <code class="docutils literal notranslate"><span class="pre">x</span></code>, which is exactly what we desired.</p>
</div></div></section>
<section id="matrix-vs-any-vector">
<h4><span class="section-number">8.1.3.3. </span>Matrix vs Any Vector<a class="headerlink" href="#matrix-vs-any-vector" title="Permalink to this heading"></a></h4>
<p>An <em>n×m</em> matrix can also be combined with
an <em>n×1</em> column vector:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[ 0.2,  0.6,  0.4,  0.4],</span>
<span class="c1">##        [ 0. ,  2. ,  4. ,  7. ],</span>
<span class="c1">##        [80. , 80. , 20. , 10. ]])</span>
</pre></div>
</div>
<p>The above propagated the column vector over all columns (left to right).</p>
<p>Similarly, combining with a <em>1×m</em> row vector:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[1.2, 2.6, 3.4, 4.4],</span>
<span class="c1">##        [1. , 2.2, 3.4, 4.7],</span>
<span class="c1">##        [1.8, 2.8, 3.2, 4.1]])</span>
</pre></div>
</div>
<p>recycles the row vector over all rows (top to bottom).</p>
<p>If one operand is a one-dimensional array or a list of length
<em>m</em>, it will be treated as a row vector. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># matrix - vector</span>
<span class="c1">## array([[-0.133,  0.067,  0.067, -0.   ],</span>
<span class="c1">##        [-0.333, -0.333,  0.067,  0.3  ],</span>
<span class="c1">##        [ 0.467,  0.267, -0.133, -0.3  ]])</span>
</pre></div>
</div>
<p>On a side note, this is an instance of <em>centring</em> of each column.
An explicit <code class="docutils literal notranslate"><span class="pre">.reshape(1,</span> <span class="pre">-1)</span></code> was not necessary.</p>
<p>Mathematically, although it is not necessarily a standard
notation, we will allow adding and subtracting row vectors
from matrices of compatible sizes:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{X}+\mathbf{t}=
\mathbf{X}+[ t_1\ t_2\ \cdots\ t_m ]=
\left[
\begin{array}{cccc}
x_{1,1} + t_1 &amp; x_{1,2} + t_2 &amp; \dots &amp; x_{1,m} + t_m \\
x_{2,1} + t_1 &amp; x_{2,2} + t_2 &amp; \dots &amp; x_{2,m} + t_m \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{n,1} + t_1 &amp; x_{n,2} + t_2 &amp; \dots &amp; x_{n,m} + t_m \\
\end{array}
\right].
\end{split}\]</div>
<p>This corresponds to shifting (translating) every row
in the matrix.</p>
<div class="proof proof-type-exercise" id="id12">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.3</span>
        
    </div><div class="proof-content">
<p>In the <a class="reference external" href="https://raw.githubusercontent.com/gagolews/teaching_data/master/marek/nhanes_adult_female_bmx_2020.csv"><code class="docutils literal notranslate"><span class="pre">nhanes_adult_female_bmx_2020</span></code></a>
dataset, standardise, normalise, and min-max scale every column.
In every case, a single line of code is sufficient.</p>
</div></div></section>
<section id="row-vector-vs-column-vector">
<h4><span class="section-number">8.1.3.4. </span>Row Vector vs Column Vector (*)<a class="headerlink" href="#row-vector-vs-column-vector" title="Permalink to this heading"></a></h4>
<p>A row vector combined with a column vector results
in an operation’s being performed on each <em>combination</em>
of <em>all</em> pairs of elements in the two arrays
(i.e., the cross-product; not just the <em>corresponding</em> pairs).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[  1,   2,   3,   4,   5,   6,   7],</span>
<span class="c1">##        [ 10,  20,  30,  40,  50,  60,  70],</span>
<span class="c1">##        [100, 200, 300, 400, 500, 600, 700]])</span>
</pre></div>
</div>
<div class="proof proof-type-exercise" id="id13">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.4</span>
        
    </div><div class="proof-content">
<p>Check out that
<strong class="command">numpy.nonzero</strong> relies on similar shape broadcasting rules
as the binary operators we discussed here,
but not with respect to all three arguments.</p>
</div></div><div class="proof proof-type-example" id="id14">

    <div class="proof-title">
        <span class="proof-type">Example 8.5</span>
        
    </div><div class="proof-content">
<p>(*) Himmelblau’s function in <a class="reference internal" href="#fig-ex-contourf"><span class="std std-numref">Figure 8.1</span></a> is only defined
by means of arithmetic operators, which all accept the kind of
shape broadcasting that we discuss in this section.
Consequently, calling <strong class="command">numpy.meshgrid</strong> in that example
to evaluate <span class="math notranslate nohighlight">\(f\)</span> on a grid of points was not really necessary:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">xg</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">yg</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="n">xg</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yg</span> <span class="o">-</span> <span class="mi">11</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">xg</span> <span class="o">+</span> <span class="n">yg</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="c1">## array([[116., 306., 296.],</span>
<span class="c1">##        [208., 178., 148.],</span>
<span class="c1">##        [340., 170., 200.],</span>
<span class="c1">##        [320.,  90., 260.],</span>
<span class="c1">##        [340., 130., 520.]])</span>
</pre></div>
</div>
<p>See also the <code class="docutils literal notranslate"><span class="pre">sparse</span></code> parameter in <strong class="command">numpy.meshgrid</strong>
and <a class="reference internal" href="430-group-by.html#fig-knn-class"><span class="std std-numref">Figure 12.9</span></a> where this function turns out useful after all.</p>
</div></div></section>
</section>
<section id="other-row-and-column-transforms">
<h3><span class="section-number">8.1.4. </span>Other Row and Column Transforms (*)<a class="headerlink" href="#other-row-and-column-transforms" title="Permalink to this heading"></a></h3>
<p>Some functions that we discussed in the previous part
of this course are equipped with the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument, which
allows to process each row or column independently,
for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[0.2, 0.4, 0.4, 0.6],</span>
<span class="c1">##        [0. , 0.2, 0.4, 0.7],</span>
<span class="c1">##        [0.1, 0.2, 0.8, 0.8]])</span>
</pre></div>
</div>
<p>sorts every row (separately). Moreover:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">rankdata</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">## array([[2. , 2. , 2.5, 2. ],</span>
<span class="c1">##        [1. , 1. , 2.5, 3. ],</span>
<span class="c1">##        [3. , 3. , 1. , 1. ]])</span>
</pre></div>
</div>
<p>computes the ranks of elements in each column.</p>
<p>Some functions have the default argument
<code class="docutils literal notranslate"><span class="pre">axis=-1</span></code>, which means that they  are applied
along the last (i.e., columns in the matrix case) axis:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1"># axis=1 here</span>
<span class="c1">## array([[ 0.4, -0.2,  0. ],</span>
<span class="c1">##        [ 0.2,  0.2,  0.3],</span>
<span class="c1">##        [ 0. , -0.6, -0.1]])</span>
</pre></div>
</div>
<p>Still, the aforementioned <strong class="command">numpy.mean</strong> is
amongst the many exceptions to this rule.</p>
<p>Compare the above with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">## array([[-0.2, -0.4,  0. ,  0.3],</span>
<span class="c1">##        [ 0.8,  0.6, -0.2, -0.6]])</span>
</pre></div>
</div>
<p>which gives the iterated differences for
each column separately (along the rows).</p>
<p>If a function (built-in or custom) in not equipped with the <code class="docutils literal notranslate"><span class="pre">axis</span></code>
argument and – instead – it was designed to work
with individual vectors,
we can propagate it over all the rows or columns
by calling <strong class="command">numpy.apply_along_axis</strong>.</p>
<p>For instance, here is another (did you solve the suggested
exercise?) way to compute the column z-scores:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">standardise</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">standardise</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">## array([[-0.39,  0.27,  0.71, -0.  ],</span>
<span class="c1">##        [-0.98, -1.34,  0.71,  1.22],</span>
<span class="c1">##        [ 1.37,  1.07, -1.41, -1.22]])</span>
</pre></div>
</div>
<p>But of course we prefer
<code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">-</span> <span class="pre">np.mean(x,</span> <span class="pre">axis=0))/np.std(x,</span> <span class="pre">axis=0)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>(*)
Matrices are iterable (in the sense of <a class="reference internal" href="130-sequential.html#sec-iterable"><span class="std std-numref">Section 3.4</span></a>),
but in an interesting way. Namely, an iterator traverses through
each row in a matrix. Writing:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">A</span>  <span class="c1"># A has 3 rows</span>
</pre></div>
</div>
<p>creates three variables, each representing a separate row
in <code class="docutils literal notranslate"><span class="pre">A</span></code>, the second of which is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">r2</span>
<span class="c1">## array([0. , 0.2, 0.4, 0.7])</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="indexing-matrices">
<span id="sec-matrix-indexing"></span><h2><span class="section-number">8.2. </span>Indexing Matrices<a class="headerlink" href="#indexing-matrices" title="Permalink to this heading"></a></h2>
<p>Recall that for unidimensional arrays, we have four possible choices
of indexers (i.e., where performing filtering like <code class="docutils literal notranslate"><span class="pre">x[i]</span></code>):</p>
<ul class="simple">
<li><p>scalar (extracts a single element),</p></li>
<li><p>slice (selects a regular subsequence, e.g., every 2nd element
or the first 6 items; returns a <em>view</em> on existing data  – it does
not make an independent copy of the subsetted elements),</p></li>
<li><p>integer vector (selects elements at given indexes),</p></li>
<li><p>logical vector (selects elements that correspond to
<code class="docutils literal notranslate"><span class="pre">True</span></code> in the indexer).</p></li>
</ul>
<p>Matrices are two-dimensional arrays. Subsetting thereof
will require two indexes. We write <code class="docutils literal notranslate"><span class="pre">A[i,</span> <span class="pre">j]</span></code>
to select rows given by <code class="docutils literal notranslate"><span class="pre">i</span></code> and columns given by <code class="docutils literal notranslate"><span class="pre">j</span></code>.
Both <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> can be one of the four above types,
so we have at least 10 different cases to consider
(skipping the symmetric ones).</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Generally:</p>
<ul class="simple">
<li><p>each scalar index reduces the dimensionality of the
subsetted object by 1;</p></li>
<li><p>slice-slice and slice-scalar indexing returns a view on
the existing array, so we need to be careful when modifying
the resulting object;</p></li>
<li><p>usually, indexing returns a submatrix (subblock),
which is a combination of elements at given rows and columns;</p></li>
<li><p>indexing with two integer or logical vectors at the same time
should be avoided.</p></li>
</ul>
</div>
<p>Let us look at all the possible scenarios in greater detail.</p>
<section id="slice-based-indexing">
<h3><span class="section-number">8.2.1. </span>Slice-Based Indexing<a class="headerlink" href="#slice-based-indexing" title="Permalink to this heading"></a></h3>
<p>Our favourite example matrix again:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="p">])</span>
</pre></div>
</div>
<p>Indexing based on two slices selects a submatrix:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>  <span class="c1"># every second row, skip the first three columns</span>
<span class="c1">## array([[0.4],</span>
<span class="c1">##        [0.1]])</span>
</pre></div>
</div>
<p>An empty slice selects all elements on the corresponding axis:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># all rows, reversed columns</span>
<span class="c1">## array([[0.4, 0.4, 0.6, 0.2],</span>
<span class="c1">##        [0.7, 0.4, 0.2, 0. ],</span>
<span class="c1">##        [0.1, 0.2, 0.8, 0.8]])</span>
</pre></div>
</div>
<p>Let us stress that the result is <em>always</em> a matrix.</p>
</section>
<section id="scalar-based-indexing">
<h3><span class="section-number">8.2.2. </span>Scalar-Based Indexing<a class="headerlink" href="#scalar-based-indexing" title="Permalink to this heading"></a></h3>
<p>Indexing by a scalar selects a given row or column,
reducing the dimensionality of the output object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
<span class="c1">## array([0.4, 0.7, 0.1])</span>
</pre></div>
</div>
<p>selects the 4th column and gives a flat vector
(we can always use the <strong class="command">reshape</strong> method to
convert the resulting object back to a matrix).</p>
<p>Furthermore:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="c1">## 0.4</span>
</pre></div>
</div>
<p>yields the element (scalar) in the first row and the last column.</p>
</section>
<section id="mixed-boolean-integer-vector-and-scalar-slice-indexers">
<h3><span class="section-number">8.2.3. </span>Mixed Boolean/Integer Vector and Scalar/Slice Indexers<a class="headerlink" href="#mixed-boolean-integer-vector-and-scalar-slice-indexers" title="Permalink to this heading"></a></h3>
<p>A logical and integer vector-like object can also be used
for element selection.
If the other indexer is a slice or a scalar, the result is
quite predictable, for instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
<span class="c1">## array([[0.4, 0.4, 0.6, 0.2],</span>
<span class="c1">##        [0.1, 0.2, 0.8, 0.8],</span>
<span class="c1">##        [0.4, 0.4, 0.6, 0.2]])</span>
</pre></div>
</div>
<p>selects the first, the last, and the first row again
and reverses the order of columns.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">,</span> <span class="p">:</span> <span class="p">]</span>
<span class="c1">## array([[0.2, 0.6, 0.4, 0.4],</span>
<span class="c1">##        [0.8, 0.8, 0.2, 0.1]])</span>
</pre></div>
</div>
<p>selects the rows from <code class="docutils literal notranslate"><span class="pre">A</span></code> where the values in the first column of <code class="docutils literal notranslate"><span class="pre">A</span></code>
are greater than 0.1.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.35</span><span class="p">,</span> <span class="p">:</span> <span class="p">]</span>
<span class="c1">## array([[0.2, 0.6, 0.4, 0.4],</span>
<span class="c1">##        [0.8, 0.8, 0.2, 0.1]])</span>
</pre></div>
</div>
<p>selects the rows whose mean is greater than 0.35.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">:</span> <span class="p">]</span>
<span class="c1">## array([[0. , 0.2, 0.4, 0.7],</span>
<span class="c1">##        [0.2, 0.6, 0.4, 0.4],</span>
<span class="c1">##        [0.8, 0.8, 0.2, 0.1]])</span>
</pre></div>
</div>
<p>orders the matrix with respect to the values in the first
column (all rows permuted in the same way, together).</p>
<div class="proof proof-type-exercise" id="id15">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.6</span>
        
    </div><div class="proof-content">
<p>In the
<a class="reference external" href="https://raw.githubusercontent.com/gagolews/teaching_data/master/marek/nhanes_adult_female_bmx_2020.csv"><code class="docutils literal notranslate"><span class="pre">nhanes_adult_female_bmx_2020</span></code></a> dataset,
select all the participants whose heights are within their
mean ± 2 standard deviations.</p>
</div></div></section>
<section id="two-vectors-as-indexers">
<h3><span class="section-number">8.2.4. </span>Two Vectors as Indexers (*)<a class="headerlink" href="#two-vectors-as-indexers" title="Permalink to this heading"></a></h3>
<p>With two vectors (logical or integer) things are a tad more
horrible, as in this case not only some
form of <em>shape broadcasting</em> comes into play
but also all the headache-inducing exceptions
listed in the perhaps not the most clearly written
<a class="reference external" href="https://numpy.org/doc/stable/user/basics.indexing.html">Advanced Indexing</a>
section of the <strong class="program">numpy</strong> manual.
Cheer up, though: things in <strong class="program">pandas</strong> are much worse;
see <a class="reference internal" href="410-data-frame.html#sec-df-indexing"><span class="std std-numref">Section 10.5</span></a>.</p>
<p>For the sake of our maintaining sanity, in practice, it is best
to be extra careful when using two vector indexers and
stick only to the scenarios discussed below.</p>
<p>For two flat integer indexers, we pick elementwisely:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="p">]</span>
<span class="c1">## array([0.6, 0.2, 0.2, 0.2, 0.6])</span>
</pre></div>
</div>
<p>yields <code class="docutils literal notranslate"><span class="pre">A[0,</span> <span class="pre">1]</span></code>, <code class="docutils literal notranslate"><span class="pre">A[-1,</span> <span class="pre">2]</span></code>, <code class="docutils literal notranslate"><span class="pre">A[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">A[2,</span> <span class="pre">2]</span></code>, and <code class="docutils literal notranslate"><span class="pre">A[0,</span> <span class="pre">1]</span></code>.</p>
<p>To select a submatrix using integer indexes,
it is best to make sure that the first indexer is a column vector,
and the second one is a row vector (or some objects like these,
e.g., compatible lists of lists).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span> <span class="p">]</span>  <span class="c1"># column vector-like list, row vector-like list</span>
<span class="c1">## array([[0.6, 0.4],</span>
<span class="c1">##        [0.8, 0.1]])</span>
</pre></div>
</div>
<p>Further, if indexing involves logical vectors,
it is best to convert them to integer ones first
(e.g., by calling <strong class="command">numpy.flatnonzero</strong>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.35</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="p">]</span>
<span class="c1">## array([[0.2, 0.4, 0.4, 0.2],</span>
<span class="c1">##        [0.8, 0.2, 0.1, 0.8]])</span>
</pre></div>
</div>
<p>The necessary reshaping can be done automatically with the
<strong class="command">numpy.ix_</strong> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.35</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">]</span>  <span class="c1"># np.ix_(rows, cols)</span>
<span class="c1">## array([[0.2, 0.4, 0.4, 0.2],</span>
<span class="c1">##        [0.8, 0.2, 0.1, 0.8]])</span>
</pre></div>
</div>
<p>Alternatively, we can always apply indexing twice instead:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.45</span><span class="p">,</span> <span class="p">:][:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="c1">## array([[0.8, 0.2, 0.1, 0.8]])</span>
</pre></div>
</div>
<p>This is only a mild inconvenience.
We will be forced to apply such double indexing anyway in
<strong class="program">pandas</strong> whenever selecting rows <em>by position</em> and columns
<em>by name</em> is required; see <a class="reference internal" href="410-data-frame.html#sec-df-indexing"><span class="std std-numref">Section 10.5</span></a>.</p>
</section>
<section id="views-on-existing-arrays">
<h3><span class="section-number">8.2.5. </span>Views on Existing Arrays (*)<a class="headerlink" href="#views-on-existing-arrays" title="Permalink to this heading"></a></h3>
<p>Only the indexing involving two slices or a slice and a scalar returns a
<a class="reference external" href="https://numpy.org/devdocs/user/basics.copies.html">view</a>
on an existing array.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="n">B</span>
<span class="c1">## array([[0.2, 0.4],</span>
<span class="c1">##        [0. , 0.4],</span>
<span class="c1">##        [0.8, 0.2]])</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> share memory. By modifying <code class="docutils literal notranslate"><span class="pre">B</span></code>
in place, e.g.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<p>the changes will be visible in <code class="docutils literal notranslate"><span class="pre">A</span></code> as well:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>
<span class="c1">## array([[-0.2,  0.6, -0.4,  0.4],</span>
<span class="c1">##        [-0. ,  0.2, -0.4,  0.7],</span>
<span class="c1">##        [-0.8,  0.8, -0.2,  0.1]])</span>
</pre></div>
</div>
<p>This is time and memory efficient, but
might lead to some unexpected results if we are being rather absent-minded.
We have been warned.</p>
</section>
<section id="adding-and-modifying-rows-and-columns">
<h3><span class="section-number">8.2.6. </span>Adding and Modifying Rows and Columns<a class="headerlink" href="#adding-and-modifying-rows-and-columns" title="Permalink to this heading"></a></h3>
<p>With slice/scalar-based indexers,
rows/columns/individual elements can be replaced by
new content in a natural way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>With <strong class="command">numpy</strong> arrays, however, brand new rows or columns cannot
be added via the index operator. Instead, the whole array needs to
be created from scratch using, e.g., one
of the functions discussed in <a class="reference internal" href="310-matrix.html#sec-stacking-array"><span class="std std-numref">Section 7.1.4</span></a>.
For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])))</span>
<span class="n">A</span>
<span class="c1">## array([[ 0.04,  0.6 , -0.4 ,  0.4 ,  0.2 ],</span>
<span class="c1">##        [ 0.  ,  0.2 , -0.4 ,  0.7 ,  0.  ],</span>
<span class="c1">##        [ 0.64,  0.8 , -0.2 ,  0.1 ,  0.8 ]])</span>
</pre></div>
</div>
</section>
</section>
<section id="matrix-multiplication-dot-products-and-the-euclidean-norm">
<span id="sec-matrix-multiply"></span><h2><span class="section-number">8.3. </span>Matrix Multiplication, Dot Products, and the Euclidean Norm<a class="headerlink" href="#matrix-multiplication-dot-products-and-the-euclidean-norm" title="Permalink to this heading"></a></h2>
<p>Matrix algebra is at the core of all the methods used in data analysis
with the matrix multiply being the most fundamental operation therein
(e.g., <span id="id2">[<a class="reference internal" href="999-bibliography.html#id74" title="M.P. Deisenroth, A.A. Faisal, and C.S. Ong. Mathematics for Machine Learning. Cambridge University Press, 2020. URL: https://mml-book.github.io/.">DFO20</a>, <a class="reference internal" href="999-bibliography.html#id133" title="J.E. Gentle. Matrix Algebra: Theory, Computations and Applications in Statistics. Springer, 2017.">Gen17</a>]</span>).</p>
<p>Given <span class="math notranslate nohighlight">\(\mathbf{A}\in\mathbb{R}^{n\times p}\)</span>
and <span class="math notranslate nohighlight">\(\mathbf{B}\in\mathbb{R}^{p\times m}\)</span>, their <em>multiply</em> is a matrix
<span class="math notranslate nohighlight">\(\mathbf{C}=\mathbf{A}\mathbf{B}\in\mathbb{R}^{n\times m}\)</span>
such that <span class="math notranslate nohighlight">\(c_{i,j}\)</span> is the sum of the <span class="math notranslate nohighlight">\(i\)</span>-th row in <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>
and the <span class="math notranslate nohighlight">\(j\)</span>-th column in <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> multiplied elementwisely:</p>
<div class="math notranslate nohighlight">
\[
c_{i,j} = a_{i, 1} b_{1, j} + a_{i, 2} b_{2, j} + \dots + a_{i, p} b_{p, j}
= \sum_{k=1}^p a_{i,k} b_{k, j},
\]</div>
<p>for <span class="math notranslate nohighlight">\(i=1,\dots,n\)</span> and <span class="math notranslate nohighlight">\(j=1,\dots,m\)</span>.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">])</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">])</span>
</pre></div>
</div>
<p>And now:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">B</span>  <span class="c1"># or: A.dot(B)</span>
<span class="n">C</span>
<span class="c1">## array([[ 3,  0,  3,  1],</span>
<span class="c1">##        [ 4,  8,  5,  7],</span>
<span class="c1">##        [ 3,  8,  2,  6],</span>
<span class="c1">##        [ 7,  8, 11,  9],</span>
<span class="c1">##        [ 2,  0,  3,  1]])</span>
</pre></div>
</div>
<p>Mathematically, we can write the above as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left[
\begin{array}{ccc}
1 &amp; 0 &amp; 1 \\
2 &amp; 2 &amp; 1 \\
3 &amp; 2 &amp; 0 \\
\mathbf{1} &amp; \mathbf{2} &amp; \mathbf{3} \\
0 &amp; 0 &amp; 1 \\
\end{array}
\right]
\,
\left[
\begin{array}{cccc}
1 &amp;  0 &amp; \mathbf{0} &amp; 0 \\
0 &amp;  4 &amp; \mathbf{1} &amp; 3 \\
2 &amp;  0 &amp; \mathbf{3} &amp; 1 \\
\end{array}
\right]
=
\left[
\begin{array}{cccc}
3 &amp;  0 &amp;  3 &amp;  1 \\
4 &amp;  8 &amp;  5 &amp;  7 \\
3 &amp;  8 &amp;  2 &amp;  6 \\
7 &amp;  8 &amp; \mathbf{11} &amp;  9 \\
2 &amp;  0 &amp;  3 &amp;  1 \\
\end{array}
\right].
\end{split}\]</div>
<p>For example, the element in the 4th row and 3rd column,
<span class="math notranslate nohighlight">\(c_{4,3}\)</span> takes the 4th row in the left matrix
<span class="math notranslate nohighlight">\(\mathbf{a}_{4,\cdot}=[1\ 2\ 3]\)</span>
and the 3rd column in the right matrix <span class="math notranslate nohighlight">\(\mathbf{b}_{\cdot,3}=[0\ 1\ 3]^T\)</span>
(they are marked in bold), multiplies the corresponding elements and
computes their sum, i.e., <span class="math notranslate nohighlight">\(c_{4,3}=1\cdot 0 + 2\cdot 1 + 3\cdot 3 = 11\)</span>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Matrix multiplication can only be performed on two
matrices of <em>compatible sizes</em> – the number of columns in the left matrix
must match the number of rows in the right operand.</p>
</div>
<p>Another example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">])</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>  <span class="c1"># np.eye(2)</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">])</span>
<span class="n">A</span> <span class="o">@</span> <span class="n">I</span>  <span class="c1"># or A.dot(I)</span>
<span class="c1">## array([[1, 2],</span>
<span class="c1">##        [3, 4]])</span>
</pre></div>
</div>
<p>We matrix-multiplied <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> by the identity matrix <span class="math notranslate nohighlight">\(\mathbf{I}\)</span>,
which is the neutral element of the said operation.
This is why the result is identical to <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>In most textbooks, just like in this one,
<span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{B}\)</span> always denotes the <em>matrix</em> multiplication.
This is a very different operation from the <em>elementwise</em> multiplication.</p>
</div>
<p>Compare the above to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">*</span> <span class="n">I</span>  <span class="c1"># elementwise multiplication</span>
<span class="c1">## array([[1, 0],</span>
<span class="c1">##        [0, 4]])</span>
</pre></div>
</div>
<div class="proof proof-type-exercise" id="id16">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.7</span>
        
    </div><div class="proof-content">
<p>(*) Show that
<span class="math notranslate nohighlight">\((\mathbf{A}\mathbf{B})^T=\mathbf{B}^T \mathbf{A}^T\)</span>.
Also notice that, typically, matrix multiplication
is not commutative.</p>
</div></div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>By definition, matrix multiplication gives a convenient means for denoting
sums of products of corresponding elements in many pairs of vectors,
which we refer to as dot products.</p>
<p>Given two vectors <span class="math notranslate nohighlight">\(\boldsymbol{x}, \boldsymbol{y} \in \mathbb{R}^p\)</span>,
their <em>dot (or scalar) product</em> is given by:</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{x} \cdot \boldsymbol{y} = \sum_{i=1}^p x_i y_i.
\]</div>
<p>In matrix multiplication terms,
if <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is a row vector
and <span class="math notranslate nohighlight">\(\mathbf{y}^T\)</span> is a column vector,
then the above can be written as <span class="math notranslate nohighlight">\(\mathbf{x} \mathbf{y}^T\)</span>.
The result is a single number.</p>
</div>
<p>In particular, a dot product of a vector and itself:</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{x} \cdot \boldsymbol{x} = \sum_{i=1}^p x_i^2,
\]</div>
<p>is the square of the Euclidean norm of <span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span>,
which – as we said in <a class="reference internal" href="220-transform-vector.html#sec-normalisation"><span class="std std-numref">Section 5.3.2.3</span></a> –
is used to measure the <em>magnitude</em> of a vector:</p>
<div class="math notranslate nohighlight">
\[
\|\boldsymbol{x}\| = \sqrt{\sum_{i=1}^p x_i^2}
=\sqrt{\boldsymbol{x} \cdot \boldsymbol{x}}
=\sqrt{\mathbf{x} \mathbf{x}^T}.
\]</div>
<p>It is worth pointing out that
the Euclidean norm fulfils (amongst others) the condition
that <span class="math notranslate nohighlight">\(\|\boldsymbol{x}\|=0\)</span> if and only if
<span class="math notranslate nohighlight">\(\boldsymbol{x}=\mathbf{0}=(0,0,\dots,0)\)</span>.
The same of course holds for its square.</p>
<div class="proof proof-type-exercise" id="id17">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.8</span>
        
    </div><div class="proof-content">
<p>Show that <span class="math notranslate nohighlight">\(\mathbf{A}^T \mathbf{A}\)</span>
gives the matrix that consists of the dot products of all the pairs
of columns in <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>
and <span class="math notranslate nohighlight">\(\mathbf{A} \mathbf{A}^T\)</span> stores the dot products of all the
pairs of rows.</p>
</div></div><p>In <a class="reference internal" href="330-relationship.html#sec-geometric-transform"><span class="std std-numref">Section 9.3.2</span></a> we will
see that matrix multiplication can be used as a way to express
certain geometrical transformations of points in a dataset,
e.g., scaling and rotating.</p>
<p>Also, in <a class="reference internal" href="330-relationship.html#sec-matrix-inverse"><span class="std std-numref">Section 9.3.3</span></a> we briefly discuss
the concept of the inverse of a matrix
and in <a class="reference internal" href="330-relationship.html#sec-svd"><span class="std std-numref">Section 9.3.4</span></a> its singular value decomposition.</p>
</section>
<section id="pairwise-distances-and-related-methods">
<span id="sec-distances"></span><h2><span class="section-number">8.4. </span>Pairwise Distances and Related Methods<a class="headerlink" href="#pairwise-distances-and-related-methods" title="Permalink to this heading"></a></h2>
<p>Many data analysis methods rely on the notion of
<em>distances</em> between points,
which quantify the extent to which two points
(e.g., two rows in a matrix) are different from each other.
Here we will be dealing with the most natural<a class="footnote-reference brackets" href="#footmanydistances" id="id3">2</a> distance
called the Euclidean metric.
We know it from school, where we measured how two points
are far away from each other using a ruler.</p>
<section id="the-euclidean-metric">
<h3><span class="section-number">8.4.1. </span>The Euclidean Metric<a class="headerlink" href="#the-euclidean-metric" title="Permalink to this heading"></a></h3>
<p>Given two points in <span class="math notranslate nohighlight">\(\mathbb{R}^m\)</span>,
<span class="math notranslate nohighlight">\(\boldsymbol{u}=(u_1,\dots,u_m)\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{v}=(v_1,\dots,v_m)\)</span>, the <em>Euclidean metric</em> is defined in terms of the corresponding Euclidean
norm:</p>
<div class="math notranslate nohighlight">
\[
\|\boldsymbol{u} - \boldsymbol{v}\| = \sqrt{
(u_1-v_1)^2 + (u_2-v_2)^2 + \dots + (u_m-v_m)^2
}
=
\sqrt{
\sum_{i=1}^m (u_i-v_i)^2
},
\]</div>
<p>that is, it is the square root of the sum of squared differences
between the corresponding coordinates.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Given two vectors of equal lengths
<span class="math notranslate nohighlight">\(\boldsymbol{x},\boldsymbol{y}\in\mathbb{R}^m\)</span>,
the dot product of their difference:</p>
<div class="math notranslate nohighlight">
\[
(\boldsymbol{x}-\boldsymbol{y})\cdot (\boldsymbol{x}-\boldsymbol{y})
= (\mathbf{x}-\mathbf{y}) (\mathbf{x}-\mathbf{y})^T
= \sum_{i=1}^{m} (x_i-y_i)^2,
\]</div>
<p>is nothing else than the square of the Euclidean distance between them.</p>
<p>In particular,
for unidimensional data (<span class="math notranslate nohighlight">\(m=1\)</span>),
we have <span class="math notranslate nohighlight">\(\|\boldsymbol{u}-\boldsymbol{v}\|=|u_1-v_1|\)</span>,
i.e., the absolute value of the difference.</p>
</div>
<div class="proof proof-type-exercise" id="id18">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.9</span>
        
    </div><div class="proof-content">
<p>Consider the following matrix <span class="math notranslate nohighlight">\(\mathbf{X}\in\mathbb{R}^{4\times 2}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{X} = \left[\begin{array}{cc}
0 &amp; 0 \\
1 &amp; 0 \\
-\frac{3}{2} &amp; 1 \\
1 &amp; 1 \\
\end{array}\right].
\end{split}\]</div>
<p>Calculate (by hand):
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{1,\cdot} - \mathbf{x}_{2,\cdot}\|\)</span>,
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{1,\cdot} - \mathbf{x}_{3,\cdot}\|\)</span>,
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{1,\cdot} - \mathbf{x}_{4,\cdot}\|\)</span>,
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{2,\cdot} - \mathbf{x}_{4,\cdot}\|\)</span>,
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{2,\cdot} - \mathbf{x}_{3,\cdot}\|\)</span>,
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{1,\cdot} - \mathbf{x}_{1,\cdot}\|\)</span>, and
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{2,\cdot} - \mathbf{x}_{1,\cdot}\|\)</span>.</p>
</div></div><p>The distances between all the possible pairs of rows
in two matrices <span class="math notranslate nohighlight">\(\mathbf{X}\in\mathbb{R}^{n\times m}\)</span>
and <span class="math notranslate nohighlight">\(\mathbf{Y}\in\mathbb{R}^{k\times m}\)</span> can be computed by calling
<strong class="command">scipy.spatial.distance.cdist</strong>.
We need to be careful, though, because they result in
a distance matrix of size <span class="math notranslate nohighlight">\(n\times k\)</span>, which can become quite large
(e.g., for <span class="math notranslate nohighlight">\(n=k=100{,}000\)</span> we would need ca. 80 GB of RAM to store it).</p>
<p>Here are the distances between all the pairs of points in the same
dataset.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span>    <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="p">]</span>
<span class="p">])</span>
<span class="kn">import</span> <span class="nn">scipy.spatial.distance</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
<span class="n">D</span>
<span class="c1">## array([[0.        , 1.        , 1.80277564, 1.41421356],</span>
<span class="c1">##        [1.        , 0.        , 2.6925824 , 1.        ],</span>
<span class="c1">##        [1.80277564, 2.6925824 , 0.        , 2.5       ],</span>
<span class="c1">##        [1.41421356, 1.        , 2.5       , 0.        ]])</span>
</pre></div>
</div>
<p>Hence, <span class="math notranslate nohighlight">\(d_{i,j}=\|\mathbf{x}_{i,\cdot}-\mathbf{x}_{j,\cdot}\|\)</span>.
That we have zeros on the diagonal
is due to the fact that <span class="math notranslate nohighlight">\(\|\boldsymbol{u} - \boldsymbol{v}\|= 0\)</span>
if and only if <span class="math notranslate nohighlight">\(\boldsymbol{u} = \boldsymbol{v}\)</span>.
Furthermore, <span class="math notranslate nohighlight">\(\|\boldsymbol{u} - \boldsymbol{v}\|=\|\boldsymbol{v} - \boldsymbol{u}\|\)</span>, which implies the symmetry of <span class="math notranslate nohighlight">\(\mathbf{D}\)</span>,
i.e., it holds <span class="math notranslate nohighlight">\(\mathbf{D}^T=\mathbf{D}\)</span></p>
<p><a class="reference internal" href="#fig-euclid-dist-ex"><span class="std std-numref">Figure 8.2</span></a>
illustrates all of the 6 non-trivial pairwise distances.
Let us emphasise that our perception of distance is disturbed because
the aspect ratio (the ratio between the range of the x-axis
to the range of the y-axis) is not 1:1.
This is why it is very important, when judging spatial relationships
between the points, to call <strong class="command">matplotlib.pyplot.axis(&quot;equal&quot;)</strong>
or set the axis limits manually (which is left as an exercise).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;ko&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="mi">0</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="mi">1</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default" id="id19">
<span id="fig-euclid-dist-ex"></span><img alt="../_images/euclid-dist-ex-3.png" src="../_images/euclid-dist-ex-3.png" />
<figcaption>
<p><span class="caption-number">Figure 8.2 </span><span class="caption-text">Distances between four example points; their perception is disturbed because the aspect ratio is not 1:1</span><a class="headerlink" href="#id19" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Some popular techniques in data science rely on
computing pairwise distances, including:</p>
<ul class="simple">
<li><p>multidimensional data aggregation (see below),</p></li>
<li><p><em>k</em>-means clustering (<a class="reference internal" href="430-group-by.html#sec-kmeans"><span class="std std-numref">Section 12.4</span></a>),</p></li>
<li><p><em>k</em>-nearest neighbour regression (<a class="reference internal" href="330-relationship.html#sec-knn-regression"><span class="std std-numref">Section 9.2.1</span></a>)
and classification (<a class="reference internal" href="430-group-by.html#sec-knn-classification"><span class="std std-numref">Section 12.3.1</span></a>),</p></li>
<li><p>missing value imputation (<a class="reference internal" href="520-missingness.html#sec-missing-data"><span class="std std-numref">Section 15.1</span></a>),</p></li>
<li><p>density estimation (which we can use outlier detection,
see <a class="reference internal" href="520-missingness.html#sec-outliers"><span class="std std-numref">Section 15.4</span></a>).</p></li>
</ul>
<p>In the sequel, whenever we apply them,
we will be assuming that data have been
appropriately preprocessed: in particular, that columns
are on the same scale (e.g., are standardised). Otherwise, computing sums
of their squared differences might not make sense at all.</p>
</div>
</section>
<section id="centroids">
<span id="sec-centroid"></span><h3><span class="section-number">8.4.2. </span>Centroids<a class="headerlink" href="#centroids" title="Permalink to this heading"></a></h3>
<p>So far we have been only discussing ways to aggregate unidimensional data
(for instance, each matrix column separately).
It turns out that some summaries can be generalised
to the multidimensional case.</p>
<p>For instance, it can be shown that the arithmetic mean of
a vector <span class="math notranslate nohighlight">\((x_1,\dots,x_n)\)</span> is a point <span class="math notranslate nohighlight">\(c\)</span> that
minimises the sum of the <em>squared</em> unidimensional distances
between itself and all the <span class="math notranslate nohighlight">\(x_i\)</span>s, i.e.,
<span class="math notranslate nohighlight">\(\sum_{i=1}^n \|x_i-c\|^2=\sum_{i=1}^n (x_i-c)^2\)</span>.</p>
<p>We can define the <em>centroid</em> of a dataset
<span class="math notranslate nohighlight">\(\mathbf{X}\in\mathbb{R}^{n\times m}\)</span> as
the point <span class="math notranslate nohighlight">\(\boldsymbol{c}\in\mathbb{R}^m\)</span> to which the overall
<em>squared</em> distance is the smallest:</p>
<div class="math notranslate nohighlight">
\[
\text{minimise}\ \sum_{i=1}^n \| \mathbf{x}_{i,\cdot}-\boldsymbol{c}\|^2
\qquad\text{w.r.t. }\boldsymbol{c}.
\]</div>
<p>It can be shown that the solution to the above is:</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{c} =
\frac{1}{n}\left(
\mathbf{x}_{1, \cdot}+\mathbf{x}_{2, \cdot}+\dots+\mathbf{x}_{n, \cdot}
\right)
=
\frac{1}{n} \sum_{i=1}^n \mathbf{x}_{i, \cdot},
\]</div>
<p>which is the componentwise arithmetic mean, i.e., its <em>j</em>-th component is:</p>
<div class="math notranslate nohighlight">
\[
c_j = \frac{1}{n} \sum_{i=1}^n x_{i, j}.
\]</div>
<p>For instance, the centroid of the dataset depicted in
<a class="reference internal" href="#fig-euclid-dist-ex"><span class="std std-numref">Figure 8.2</span></a> is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">c</span>
<span class="c1">## array([0.125, 0.5  ])</span>
</pre></div>
</div>
<p>Centroids are, amongst others, a basis for the <em>k</em>-means
clustering method that we discuss in <a class="reference internal" href="430-group-by.html#sec-kmeans"><span class="std std-numref">Section 12.4</span></a>.</p>
</section>
<section id="multidimensional-dispersion-and-other-aggregates">
<span id="sec-aggmultidim"></span><h3><span class="section-number">8.4.3. </span>Multidimensional Dispersion and Other Aggregates<a class="headerlink" href="#multidimensional-dispersion-and-other-aggregates" title="Permalink to this heading"></a></h3>
<p>Furthermore, as a measure of multidimensional dispersion,
we can consider the natural generalisation of the standard deviation:</p>
<div class="math notranslate nohighlight">
\[
s=
\sqrt{
\frac{1}{n}
\sum_{i=1}^n
\| \mathbf{x}_{i,\cdot}-\boldsymbol{c}\|^2
},
\]</div>
<p>being the square root of the average squared distance
to the centroid. Notice that <span class="math notranslate nohighlight">\(s\)</span> is a single number.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="c1">## 1.1388041973930374</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>(**) Generalising other aggregation
functions is not a trivial task, because, amongst others,
there is no natural linear ordering relation in the
multidimensional space (see, e.g., <span id="id4">[<a class="reference internal" href="999-bibliography.html#id24" title="R. Pérez-Fernández, B. De Baets, and M. Gagolewski. A taxonomy of monotonicity properties for the aggregation of multidimensional data. Information Fusion, 52:322–334, 2019. doi:10.1016/j.inffus.2019.05.006.">PFBG19</a>]</span>).
For instance, any point on the convex hull of a dataset
could serve as an analogue of the minimal and maximal observation.</p>
<p>Furthermore, the componentwise median does not behave nicely
(it may, for example, fall outside the convex hull). Instead,
we usually consider a different generalisation of the median:
the point <span class="math notranslate nohighlight">\(\boldsymbol{m}\)</span> which minimises the sum of distances (not squared),
<span class="math notranslate nohighlight">\(\sum_{i=1}^n \| \mathbf{x}_{i,\cdot}-\boldsymbol{m}\|\)</span>.
Sadly, it does not have an analytic solution, but
it can be determined algorithmically.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>(**) A bag plot <span id="id5">[<a class="reference internal" href="999-bibliography.html#id136" title="P.J. Rousseeuw, I. Ruts, and J.W. Tukey. The bagplot: A bivariate boxplot. The American Statistician, 53(4):382–387, 1999. doi:10.2307/2686061.">RRT99</a>]</span>
is one of the possible multidimensional generalisations
of the box-and-whisker plot. Unfortunately, its use is quite limited
due to its low popularity amongst practitioners.</p>
</div>
</section>
<section id="fixed-radius-and-k-nearest-neighbour-search">
<span id="sec-knn-vs-radius"></span><h3><span class="section-number">8.4.4. </span>Fixed-Radius and <em>K</em>-Nearest Neighbour Search<a class="headerlink" href="#fixed-radius-and-k-nearest-neighbour-search" title="Permalink to this heading"></a></h3>
<p>Several data analysis techniques rely upon
aggregating information about what is happening in the
<em>local neighbourhoods</em> of the points.
Let <span class="math notranslate nohighlight">\(\mathbf{X}\in\mathbb{R}^{n\times m}\)</span> be a dataset
and <span class="math notranslate nohighlight">\(\boldsymbol{x}'\in\mathbb{R}^m\)</span> be some point, not necessarily
from <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>. We have two options:</p>
<ul>
<li><p><em>fixed-radius search</em>: for some radius <span class="math notranslate nohighlight">\(r&gt;0\)</span>,
we seek the indexes of all the points in <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> whose distance to
<span class="math notranslate nohighlight">\(\boldsymbol{x}'\)</span> is not greater than <span class="math notranslate nohighlight">\(r\)</span>:</p>
<div class="math notranslate nohighlight">
\[
    B_r(\boldsymbol{x}') = \left\{
    i: \|\mathbf{x}_{i,\cdot} - \boldsymbol{x}'\| \le r
    \right\};
    \]</div>
</li>
<li><p><em>few nearest neighbour search</em>: for some (usually small) integer <span class="math notranslate nohighlight">\(k\ge 1\)</span>,
we seek the indexes of the <span class="math notranslate nohighlight">\(k\)</span> points in <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>
which are the closest to <span class="math notranslate nohighlight">\(\boldsymbol{x}'\)</span>:</p>
<div class="math notranslate nohighlight">
\[
    N_k(\boldsymbol{x}') = \{
    i_1, i_2, \dots, i_k
    \},
    \]</div>
<p>such that for all <span class="math notranslate nohighlight">\(j\not\in\{i_1,\dots,i_k\}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
    \| \mathbf{x}_{i_1,\cdot} -\boldsymbol{x}'\|
    \le
    \| \mathbf{x}_{i_2,\cdot} -\boldsymbol{x}' \|
    \le\dots\le
    \| \mathbf{x}_{i_k,\cdot} -\boldsymbol{x}' \|
    \le
    \| \mathbf{x}_{j,\cdot} -\boldsymbol{x}' \|.
    \]</div>
</li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>In <span class="math notranslate nohighlight">\(\mathbb{R}^1\)</span>,
<span class="math notranslate nohighlight">\(B_r(\boldsymbol{x'})\)</span> is an interval of length <span class="math notranslate nohighlight">\(2r\)</span>
centred at <span class="math notranslate nohighlight">\(\boldsymbol{x'}\)</span>,
i.e., <span class="math notranslate nohighlight">\([x_1'-r, x_1'+r]\)</span>.
In <span class="math notranslate nohighlight">\(\mathbb{R}^2\)</span>,
<span class="math notranslate nohighlight">\(B_r(\boldsymbol{x}')\)</span> is a circle of radius <span class="math notranslate nohighlight">\(r\)</span>
centred at <span class="math notranslate nohighlight">\((x_1', x_2')\)</span>.
More generally, we call <span class="math notranslate nohighlight">\(B_r(\boldsymbol{x})\)</span>
an <span class="math notranslate nohighlight">\(m\)</span>-dimensional (Euclidean) ball or a solid hypersphere.</p>
</div>
<p>Here is an example dataset, consisting of some randomly generated points
(see <a class="reference internal" href="#fig-euclid-search-ex"><span class="std std-numref">Figure 8.3</span></a>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">777</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">x_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Local neighbourhoods can of course be determined
by computing the distances between each point in <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>
and <span class="math notranslate nohighlight">\(\boldsymbol{x}'\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.spatial.distance</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">x_test</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>For instance, here are the indexes
of the points in <span class="math notranslate nohighlight">\(B_{0.75}(\boldsymbol{x}')\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="mf">0.75</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">D</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span>
<span class="n">B</span>
<span class="c1">## array([ 1, 11, 14, 16, 24])</span>
</pre></div>
</div>
<p>And here are the 11 nearest neighbours, <span class="math notranslate nohighlight">\(N_{11}(\boldsymbol{x}')\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))[:</span><span class="n">k</span><span class="p">]</span>
<span class="n">N</span>
<span class="c1">## array([14, 24, 16, 11,  1, 22,  7, 19,  0,  9, 15])</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#fig-euclid-search-ex"><span class="std std-numref">Figure 8.3</span></a> for an illustration
(observe that the aspect ratio is set to 1:1 as otherwise the circle
would look like an ellipse).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span><span class="n">x_test</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
        <span class="p">[</span><span class="n">x_test</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="p">[</span><span class="n">x_test</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">]],</span>
        <span class="s2">&quot;r:&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span>
    <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;bo&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_test</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_test</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;rX&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_test</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_test</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;$</span><span class="se">\\</span><span class="s2">mathbf</span><span class="si">{x}</span><span class="s2">&#39;$&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default" id="id20">
<span id="fig-euclid-search-ex"></span><img alt="../_images/euclid-search-ex-5.png" src="../_images/euclid-search-ex-5.png" />
<figcaption>
<p><span class="caption-number">Figure 8.3 </span><span class="caption-text">Fixed-radius vs few nearest neighbour search</span><a class="headerlink" href="#id20" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="spatial-search-with-k-d-trees">
<h3><span class="section-number">8.4.5. </span>Spatial Search with <em>K</em>-d Trees<a class="headerlink" href="#spatial-search-with-k-d-trees" title="Permalink to this heading"></a></h3>
<p>For efficiency reasons,
it is better to rely on dedicated spatial search data structures,
especially if we have a large number of neighbourhood-related queries.
<strong class="program">scipy</strong> implements such a search algorithm based on the
so-called <em>K</em>-dimensional trees (<em>K</em>-d trees<a class="footnote-reference brackets" href="#footkd" id="id6">3</a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>(*)
In <em>K</em>-d trees, the data space is partitioned into hyperrectangles
along the axes of the Cartesian coordinate system
(standard basis). Thanks to such a representation,
all subareas which are too far from the point of interest
can be pruned to speed up the search.</p>
</div>
<p>Let us create the data structure for searching within the
above <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> matrix.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.spatial</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">KDTree</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>Assume we would like to make queries with regard to the 3 following
pivot points.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="p">])</span>
</pre></div>
</div>
<p>Here are the results for the fixed radius searches <span class="math notranslate nohighlight">\((r=0.75)\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">)</span>
<span class="c1">## array([list([1, 11, 14, 16, 24]), list([20]), list([])], dtype=object)</span>
</pre></div>
</div>
<p>We see that the search was nicely vectorised: we made a query about three
points at the same time. As a result, we received a list-like object
storing three lists representing the indexes of interest. Note that in the
case of the 3rd point, there are no elements
in <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> within the range (ball) of interest, hence the empty index
list.</p>
<p>And here are the 5 nearest neighbours:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">distances</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># returns a tuple of length 2</span>
</pre></div>
</div>
<p>We obtained both the distances to the nearest neighbours:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">distances</span>
<span class="c1">## array([[0.31457701, 0.44600012, 0.54848109, 0.64875661, 0.71635172],</span>
<span class="c1">##        [0.20356263, 1.45896222, 1.61587605, 1.64870864, 2.04640408],</span>
<span class="c1">##        [1.2494805 , 1.35482619, 1.93984334, 1.95938464, 2.08926502]])</span>
</pre></div>
</div>
<p>as well as the indexes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">indexes</span>
<span class="c1">## array([[14, 24, 16, 11,  1],</span>
<span class="c1">##        [20,  5, 13,  2,  9],</span>
<span class="c1">##        [17,  3, 21, 12, 22]])</span>
</pre></div>
</div>
<p>Each of them is a matrix with 3 rows (corresponding to the number
of pivot points) and 5 columns (the number of neighbours sought).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>(*)
We expect the <em>K</em>-d trees to be much faster than the brute-force approach
(where we compute all pairwise distances) in low-dimensional spaces.
Nonetheless, due to the phenomenon called the <em>curse of dimensionality</em>,
sometimes already for <span class="math notranslate nohighlight">\(m\ge 5\)</span> the speed gains might be very small;
see, e.g., <span id="id7">[<a class="reference internal" href="999-bibliography.html#id118" title="A. Blum, J. Hopcroft, and R. Kannan. Foundations of Data Science. Cambridge University Press, 2020. URL: https://www.cs.cornell.edu/jeh/book.pdf.">BHK20</a>]</span>.</p>
</div>
</section>
</section>
<section id="exercises">
<h2><span class="section-number">8.5. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading"></a></h2>
<div class="proof proof-type-exercise" id="id21">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.10</span>
        
    </div><div class="proof-content">
<p>Does <strong class="command">numpy.mean</strong><strong class="command">(A, axis=0)</strong>
compute rowwise or columnwise means?</p>
</div></div><div class="proof proof-type-exercise" id="id22">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.11</span>
        
    </div><div class="proof-content">
<p>How does shape broadcasting work? List the most common pairs of shape cases
when performing arithmetic operations like addition or multiplication.</p>
</div></div><div class="proof proof-type-exercise" id="id23">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.12</span>
        
    </div><div class="proof-content">
<p>What are the possible matrix indexing schemes
and how do they behave?</p>
</div></div><div class="proof proof-type-exercise" id="id24">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.13</span>
        
    </div><div class="proof-content">
<p>Which kinds of matrix indexers return a view on an existing array?</p>
</div></div><div class="proof proof-type-exercise" id="id25">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.14</span>
        
    </div><div class="proof-content">
<p>(*) How can we select a submatrix comprised of
the first and the last row and the first and the last column?</p>
</div></div><div class="proof proof-type-exercise" id="id26">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.15</span>
        
    </div><div class="proof-content">
<p>Why appropriate data preprocessing is required when computing
the Euclidean distance between points?</p>
</div></div><div class="proof proof-type-exercise" id="id27">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.16</span>
        
    </div><div class="proof-content">
<p>What is the relationship between the dot product,
the Euclidean norm, and the Euclidean distance?</p>
</div></div><div class="proof proof-type-exercise" id="id28">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.17</span>
        
    </div><div class="proof-content">
<p>What is a centroid? How is it defined by means of the Euclidean distance
between the points in a dataset?</p>
</div></div><div class="proof proof-type-exercise" id="id29">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.18</span>
        
    </div><div class="proof-content">
<p>What is the difference between the fixed-radius and few nearest-neighbours
search?</p>
</div></div><div class="proof proof-type-exercise" id="id30">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.19</span>
        
    </div><div class="proof-content">
<p>(*) When <em>K</em>-d trees or other spatial search data structures might
be better than a brute-force search with
<strong class="command">scipy.spatial.distance.cdist</strong>?</p>
</div></div><hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="footsquare"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>This is not the same as matrix-multiply by itself
which we cover in <a class="reference internal" href="#sec-matrix-multiply"><span class="std std-numref">Section 8.3</span></a>.</p>
</dd>
<dt class="label" id="footmanydistances"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>There are many possible distances,
allowing to measure the similarity of points not only in <span class="math notranslate nohighlight">\(\mathbb{R}^m\)</span>,
but also character strings (e.g., the Levenshtein metric),
ratings (e.g., cosine dissimilarity), etc.; there is even an
encyclopedia of distances <span id="id8">[<a class="reference internal" href="999-bibliography.html#id110" title="M.M. Deza and E. Deza. Encyclopedia of Distances. Springer, 2014.">DD14</a>]</span>.</p>
</dd>
<dt class="label" id="footkd"><span class="brackets"><a class="fn-backref" href="#id6">3</a></span></dt>
<dd><p>In our context, we should prefer referring to them as <em>m</em>-d trees,
but let us stick with the traditional name.</p>
</dd>
</dl>
</section>
</section>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="330-relationship.html" class="btn btn-neutral float-right" title="9. Exploring Relationships Between Variables" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="310-matrix.html" class="btn btn-neutral float-left" title="7. Multidimensional Numeric Data at a Glance" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        Copyright &#169; 2022 by <a href="https://www.gagolewski.com">Marek Gagolewski</a>. Some rights reserved. Licensed under <a href='https://creativecommons.org/licenses/by-nc-nd/4.0/'>CC BY-NC-ND 4.0</a>.

    Built with <a href="https://sphinx-doc.org/">Sphinx</a>
    and a customised <a href="https://github.com/rtfd/sphinx_rtd_theme">rtd</a>
    theme.
      <span class="lastupdated">
        Last updated on 2022-08-06T15:52:11+1000.
      </span>


    This site will never display any ads: it is a non-profit project.
    It does not collect any data.

    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>