<!DOCTYPE html>


<html class="writer-html5" lang="en" >
<!-- Copyright (C) 2020-2022, Marek Gagolewski <https://www.gagolewski.com> -->

<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>9. Transforming, Aggregating, and Filtering Multidimensional Data &mdash; Minimalist Data Wrangling with Python by Marek Gagolewski</title>
  

  
  
  <script async defer src="https://buttons.github.io/buttons.js"></script>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/proof.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  
    <link rel="canonical" href="https://datawranglingpy.gagolewski.com/chapter/320-transform-matrix.html" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/proof.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="10. 🚧 Exploring Relationships Between Variables" href="330-corelation.html" />
    <link rel="prev" title="8. Multidimensional Numeric Data at a Glance" href="310-matrix.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html"> Minimalist Data Wrangling with Python [DRAFTv0.2.2]
          

          
          </a>

          <div class="version">
          by <a style="color: inherit" href="https://www.gagolewski.com">Marek Gagolewski</a>
          </div>

<!--
          
            
            
              <div class="version">
                by Marek Gagolewski
              </div>
            
          
-->

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search phrase..." />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Start Here</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="000-preface.html">Preface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introducing Python</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="110-setup.html">1. Getting Started with Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="120-scalar.html">2. Scalar Types and Control Structures in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="130-sequential.html">3. Sequential and Other Types in Python</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Unidimensional Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="210-vector.html">4. Unidimensional Numeric Data and Their Distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="220-aggregate.html">5. Aggregating Numeric Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="230-transform-vector.html">6. Transforming and Filtering Numeric Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="240-distribution-uni.html">7. Continuous Probability Distributions (*)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Multidimensional Data</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="310-matrix.html">8. Multidimensional Numeric Data at a Glance</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">9. Transforming, Aggregating, and Filtering Multidimensional Data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#vectorised-mathematical-functions">9.1. Vectorised Mathematical Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aggregation-functions">9.2. Aggregation Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#arithmetic-logical-and-comparison-operations">9.3. Arithmetic, Logical, and Comparison Operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#matrix-vs-scalar">9.3.1. Matrix vs Scalar</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matrix-vs-matrix">9.3.2. Matrix vs Matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matrix-vs-any-vector">9.3.3. Matrix vs Any Vector</a></li>
<li class="toctree-l3"><a class="reference internal" href="#row-vector-vs-column-vector">9.3.4. Row Vector vs Column Vector (*)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#other-row-and-column-transforms">9.4. Other Row and Column Transforms (*)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filtering">9.5. Filtering</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#slice-based-indexing">9.5.1. Slice-Based Indexing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scalar-based-indexing">9.5.2. Scalar-Based Indexing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixing-vectors-with-scalars-or-slices">9.5.3. Mixing Vectors with Scalars or Slices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#two-vectors-as-indexers">9.5.4. Two Vectors as Indexers (*)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#views-on-existing-arrays">9.5.5. Views on Existing Arrays (*)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">9.6. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="330-corelation.html">10. 🚧 Exploring Relationships Between Variables</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Heterogeneous Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="410-dataframe.html">11. Introducing Data Frames</a></li>
<li class="toctree-l1"><a class="reference internal" href="420-categorical.html">12. Handling Categorical Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="430-groupby.html">13. 🚧 Processing Data in Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="440-sql.html">14. Accessing Databases</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Text and Other Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="510-text.html">15. Working with Text Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="520-regex.html">16. Regular Expressions (*)</a></li>
<li class="toctree-l1"><a class="reference internal" href="530-missingness.html">17. Outliers, Missing, Censored, and Incorrect Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="540-time.html">18. Time Series</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="998-changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="999-bibliography.html">Bibliography</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://datawranglingpy.gagolewski.com/datawranglingpy.pdf">This Book in PDF</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/datawranglingpy/blob/master/CODE_OF_CONDUCT.md">Report Bugs or Typos</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/teaching_data">Datasets</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.gagolewski.com">Author</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Minimalist Data Wrangling with Python [DRAFTv0.2.2]</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          



















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">9. </span>Transforming, Aggregating, and Filtering Multidimensional Data</li>
    
    
      <li class="wy-breadcrumbs-aside">

        
        
        <a class="github-button" href="https://github.com/gagolews/datawranglingpy" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star gagolews/datawranglingpy on GitHub">Star</a>
        


        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="330-corelation.html" class="btn btn-neutral float-right" title="10. 🚧 Exploring Relationships Between Variables" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      
      
        <a href="310-matrix.html" class="btn btn-neutral float-left" title="8. Multidimensional Numeric Data at a Glance" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="tex2jax_ignore mathjax_ignore section" id="transforming-aggregating-and-filtering-multidimensional-data">
<span id="chap-transform-matrix"></span><h1><span class="section-number">9. </span>Transforming, Aggregating, and Filtering Multidimensional Data<a class="headerlink" href="#transforming-aggregating-and-filtering-multidimensional-data" title="Permalink to this headline"></a></h1>
<blockquote>
<div><p><em>This is an early draft of</em> Minimalist Data Wrangling with Python <em>by
<a class="reference external" href="https://www.gagolewski.com">Marek Gagolewski</a>. It’s distributed
in the hope that it’ll be useful. Any
<a class="reference external" href="https://github.com/gagolews/datawranglingpy/blob/master/CODE_OF_CONDUCT.md">bug/typos reports/fixes</a>
are appreciated. Although available online, this is a whole course,
and should be read from the beginning to the end. In particular,
refer to the <a class="reference internal" href="000-preface.html#chap-preface"><span class="std std-ref">Preface</span></a> for general introductory remarks.</em></p>
</div></blockquote>
<p>Below we will study how the vector operations
that we discussed in <a class="reference internal" href="230-transform-vector.html#chap-transform-vector"><span class="std std-numref">Chapter 6</span></a>
can be extended to matrices.
In many cases, we’ll end up applying the same transform either
on every matrix element separately, or on each row or column.
They are all a brilliant example of the <em>write less, do more</em> principle
in practice.</p>
<div class="section" id="vectorised-mathematical-functions">
<h2><span class="section-number">9.1. </span>Vectorised Mathematical Functions<a class="headerlink" href="#vectorised-mathematical-functions" title="Permalink to this headline"></a></h2>
<p>Applying vectorised functions such
as <strong class="command">numpy.round</strong>, <strong class="command">numpy.log</strong>, and <strong class="command">numpy.exp</strong>
returns an array of the same shape, with all elements
transformed accordingly.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="p">])</span>  <span class="c1"># example matrix that we&#39;ll be using below</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="c1">## array([[0.04, 0.36, 0.16, 0.16],</span>
<span class="c1">##        [0.  , 0.04, 0.16, 0.49],</span>
<span class="c1">##        [0.64, 0.64, 0.04, 0.01]])</span>
</pre></div>
</div>
<p>takes the square of every element.</p>
<p>More generally, using mathematical notation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
f(\mathbf{X})=
\left[
\begin{array}{cccc}
f(x_{1,1}) &amp; f(x_{1,2}) &amp; \cdots &amp; f(x_{1,m}) \\
f(x_{2,1}) &amp; f(x_{2,2}) &amp; \cdots &amp; f(x_{2,m}) \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
f(x_{n,1}) &amp; f(x_{n,2}) &amp; \cdots &amp; f(x_{n,m}) \\
\end{array}
\right].
\end{split}\]</div>
</div>
<div class="section" id="aggregation-functions">
<h2><span class="section-number">9.2. </span>Aggregation Functions<a class="headerlink" href="#aggregation-functions" title="Permalink to this headline"></a></h2>
<p>Aggregation functions (e.g., <strong class="command">numpy.mean</strong>, <strong class="command">numpy.quantile</strong>)
can summarise:</p>
<ul class="simple">
<li><p>all data into a single number (<code class="docutils literal notranslate"><span class="pre">axis=None</span></code>, being the default),</p></li>
<li><p>data in each row (<code class="docutils literal notranslate"><span class="pre">axis=1</span></code>),</p></li>
<li><p>data in each column (<code class="docutils literal notranslate"><span class="pre">axis=0</span></code>).</p></li>
</ul>
<p>Here are the examples corresponding to the above cases:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="c1">## 0.39999999999999997</span>
<span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([0.4  , 0.325, 0.475])</span>
<span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">## array([0.33333333, 0.53333333, 0.33333333, 0.4       ])</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Let us repeat, <code class="docutils literal notranslate"><span class="pre">axis=1</span></code> does not mean
that we get the column means (even though
columns constitute the 2nd axis, and we count starting at 0).
It denotes the axis <em>along</em> which the matrix is sliced.
Sadly, even yours truly sometimes does not get it right.</p>
</div>
<div class="proof proof-type-exercise" id="id1">

    <div class="proof-title">
        <span class="proof-type">Exercise 9.1</span>
        
    </div><div class="proof-content">
<p>Given the <a class="reference external" href="https://raw.githubusercontent.com/gagolews/teaching_data/master/marek/nhanes_adult_female_bmx_2020.csv"><code class="docutils literal notranslate"><span class="pre">nhanes_adult_female_bmx_2020</span></code></a>
dataset, compute the mean, standard deviation, minimum,
and maximum of each body measurement.</p>
</div></div></div>
<div class="section" id="arithmetic-logical-and-comparison-operations">
<h2><span class="section-number">9.3. </span>Arithmetic, Logical, and Comparison Operations<a class="headerlink" href="#arithmetic-logical-and-comparison-operations" title="Permalink to this headline"></a></h2>
<p>Recall that for vectors, binary operators
such as `<strong class="command">+</strong>`, `<strong class="command">*</strong>`, `<strong class="command">==</strong>`,
`<strong class="command">&lt;=</strong>`, and `<strong class="command">&amp;</strong>`
and similar elementwise functions (e.g., <strong class="command">numpy.minimum</strong>)
can be applied if both inputs are of the same length,
for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="c1">## array([   7,  -60,  200, 8000])</span>
</pre></div>
</div>
<p>Alternatively, one input can be a scalar:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">])</span> <span class="o">*</span> <span class="o">-</span><span class="mi">3</span>
<span class="c1">## array([   -3,   -30,  -300, -3000])</span>
</pre></div>
</div>
<p>More generally, a set of rules referred in the
<strong class="program">numpy</strong> manual to as
<a class="reference external" href="https://numpy.org/devdocs/user/basics.broadcasting.html"><em>broadcasting</em></a>
describes how this package handles arrays of different shapes.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Generally, for two matrices, their column/row numbers much match
or be equal to 1.
Also, if one operand is a 1-dimensional array, it will be promoted
to a row vector.</p>
</div>
<p>Let us explore all the possible cases.</p>
<div class="section" id="matrix-vs-scalar">
<h3><span class="section-number">9.3.1. </span>Matrix vs Scalar<a class="headerlink" href="#matrix-vs-scalar" title="Permalink to this headline"></a></h3>
<p>If one operand is a scalar, then it is going to be propagated
over all matrix elements, for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="p">])</span>  <span class="c1"># example matrix</span>
</pre></div>
</div>
<p>And now:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">A</span>
<span class="c1">## array([[-0.2, -0.6, -0.4, -0.4],</span>
<span class="c1">##        [-0. , -0.2, -0.4, -0.7],</span>
<span class="c1">##        [-0.8, -0.8, -0.2, -0.1]])</span>
</pre></div>
</div>
<p>changes the sign of every element, which is,
mathematically,
an instance of multiplying a matrix <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> by a scalar <span class="math notranslate nohighlight">\(c\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}
c\mathbf{X}=
\left[
\begin{array}{cccc}
cx_{1,1} &amp; cx_{1,2} &amp; \cdots &amp; cx_{1,m} \\
cx_{2,1} &amp; cx_{2,2} &amp; \cdots &amp; cx_{2,m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
cx_{n,1} &amp; cx_{n,2} &amp; \cdots &amp; cx_{n,m} \\
\end{array}
\right].
\end{split}\]</div>
<p>Furthermore:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="o">**</span><span class="mi">2</span>
<span class="c1">## array([[0.04, 0.36, 0.16, 0.16],</span>
<span class="c1">##        [0.  , 0.04, 0.16, 0.49],</span>
<span class="c1">##        [0.64, 0.64, 0.04, 0.01]])</span>
</pre></div>
</div>
<p>takes the square of each element
(this is not the same as matrix-multiply by itself
which we cover in the matrix algebra section).</p>
<p>Also:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">&gt;=</span> <span class="mf">0.25</span>
<span class="c1">## array([[False,  True,  True,  True],</span>
<span class="c1">##        [False, False,  True,  True],</span>
<span class="c1">##        [ True,  True, False, False]])</span>
</pre></div>
</div>
<p>compares each element to 0.25.</p>
</div>
<div class="section" id="matrix-vs-matrix">
<h3><span class="section-number">9.3.2. </span>Matrix vs Matrix<a class="headerlink" href="#matrix-vs-matrix" title="Permalink to this headline"></a></h3>
<p>For two matrices of identical sizes, we will be
acting on the corresponding elements:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># just an example</span>
<span class="n">B</span>  <span class="c1"># a lower triangular 0-1 matrix</span>
<span class="c1">## array([[1., 0., 0., 0.],</span>
<span class="c1">##        [1., 1., 0., 0.],</span>
<span class="c1">##        [1., 1., 1., 0.]])</span>
</pre></div>
</div>
<p>And now:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">*</span> <span class="n">B</span>
<span class="c1">## array([[0.2, 0. , 0. , 0. ],</span>
<span class="c1">##        [0. , 0.2, 0. , 0. ],</span>
<span class="c1">##        [0.8, 0.8, 0.2, 0. ]])</span>
</pre></div>
</div>
<p>multiplies each <span class="math notranslate nohighlight">\(a_{i,j}\)</span> by the corresponding <span class="math notranslate nohighlight">\(b_{i,j}\)</span>.</p>
<p>This extends on the idea from algebra that given
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> with <em>n</em> rows and <em>m</em> columns each,
the result of <span class="math notranslate nohighlight">\(+\)</span> (or <span class="math notranslate nohighlight">\(-\)</span>) would be for instance:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{A} + \mathbf{B}=
\left[
\begin{array}{cccc}
a_{1,1}+b_{1,1} &amp; a_{1,2}+b_{1,2} &amp; \cdots &amp; a_{1,m}+b_{1,m} \\
a_{2,1}+b_{2,1} &amp; a_{2,2}+b_{1,2} &amp; \cdots &amp; a_{2,m}+b_{2,m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{n,1}+b_{n,1} &amp; a_{n,2}+b_{n,2} &amp; \cdots &amp; a_{n,m}+b_{n,m} \\
\end{array}
\right].
\end{split}\]</div>
<p>Thanks to the matrix-matrix and matrix-scalar operations
we can perform various tests on an per-element basis, e.g.,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;=</span> <span class="mf">0.25</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A</span> <span class="o">&lt;=</span> <span class="mf">0.75</span><span class="p">)</span>  <span class="c1"># logical matrix &amp; logical matrix</span>
<span class="c1">## array([[False,  True,  True,  True],</span>
<span class="c1">##        [False, False,  True,  True],</span>
<span class="c1">##        [False, False, False, False]])</span>
</pre></div>
</div>
</div>
<div class="section" id="matrix-vs-any-vector">
<h3><span class="section-number">9.3.3. </span>Matrix vs Any Vector<a class="headerlink" href="#matrix-vs-any-vector" title="Permalink to this headline"></a></h3>
<p>An <em>n×m</em> matrix can also be combined with
an <em>n×1</em> column vector:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[ 0.2,  0.6,  0.4,  0.4],</span>
<span class="c1">##        [ 0. ,  2. ,  4. ,  7. ],</span>
<span class="c1">##        [80. , 80. , 20. , 10. ]])</span>
</pre></div>
</div>
<p>The above propagated the column vector over all columns (left to right).</p>
<p>Similarly, combining with an <em>1×m</em> row vector:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[1.2, 2.6, 3.4, 4.4],</span>
<span class="c1">##        [1. , 2.2, 3.4, 4.7],</span>
<span class="c1">##        [1.8, 2.8, 3.2, 4.1]])</span>
</pre></div>
</div>
<p>recycles the row vector over all rows (top to bottom).</p>
<p>If one operand is a 1-dimensional array or a list of length
<em>m</em>, it will be treated as a row vector.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">## array([[-0.133,  0.067,  0.067, -0.   ],</span>
<span class="c1">##        [-0.333, -0.333,  0.067,  0.3  ],</span>
<span class="c1">##        [ 0.467,  0.267, -0.133, -0.3  ]])</span>
</pre></div>
</div>
<p>This resulted in each column mean’s being 0. An explicit <code class="docutils literal notranslate"><span class="pre">.reshape(1,</span> <span class="pre">-1)</span></code>
was not necessary.</p>
<p>However, subtracting the row means already requires
some extra labour:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[-0.2  ,  0.2  ,  0.   ,  0.   ],</span>
<span class="c1">##        [-0.325, -0.125,  0.075,  0.375],</span>
<span class="c1">##        [ 0.325,  0.325, -0.275, -0.375]])</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-</span> <span class="pre">np.mean(A,</span> <span class="pre">axis=1)</span></code> would raise an exception.</p>
<div class="proof proof-type-exercise" id="id2">

    <div class="proof-title">
        <span class="proof-type">Exercise 9.2</span>
        
    </div><div class="proof-content">
<p>Standardise, normalise, and min-max scale
each column in the <a class="reference external" href="https://raw.githubusercontent.com/gagolews/teaching_data/master/marek/nhanes_adult_female_bmx_2020.csv"><code class="docutils literal notranslate"><span class="pre">nhanes_adult_female_bmx_2020.csv</span></code></a>
dataset using a single line of code.</p>
</div></div></div>
<div class="section" id="row-vector-vs-column-vector">
<h3><span class="section-number">9.3.4. </span>Row Vector vs Column Vector (*)<a class="headerlink" href="#row-vector-vs-column-vector" title="Permalink to this headline"></a></h3>
<p>As a bonus, let us quickly mention that
a row vector combined with a column vector results
in an operation’s being performed on each <em>combination</em>
of <em>all</em> pairs of elements in the two arrays
(i.e., the cross-product; not just the <em>corresponding</em> pairs).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[  1,   2,   3,   4,   5,   6,   7],</span>
<span class="c1">##        [ 10,  20,  30,  40,  50,  60,  70],</span>
<span class="c1">##        [100, 200, 300, 400, 500, 600, 700]])</span>
</pre></div>
</div>
<div class="proof proof-type-exercise" id="id3">

    <div class="proof-title">
        <span class="proof-type">Exercise 9.3</span>
        
    </div><div class="proof-content">
<p>(**) Check out that
<strong class="command">numpy.where</strong> relies on similar shape broadcasting rules
as the binary operators we have discussed here,
however, not with regards to all the 3 arguments.</p>
</div></div></div>
</div>
<div class="section" id="other-row-and-column-transforms">
<h2><span class="section-number">9.4. </span>Other Row and Column Transforms (*)<a class="headerlink" href="#other-row-and-column-transforms" title="Permalink to this headline"></a></h2>
<p>Some functions that we have already discussed in the previous part
of this course are  equipped with the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument, which
allows to process each row or column independently,
for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[0.2, 0.4, 0.4, 0.6],</span>
<span class="c1">##        [0. , 0.2, 0.4, 0.7],</span>
<span class="c1">##        [0.1, 0.2, 0.8, 0.8]])</span>
</pre></div>
</div>
<p>sorts every row (separately). Moreover:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">rankdata</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">## array([[2. , 2. , 2.5, 2. ],</span>
<span class="c1">##        [1. , 1. , 2.5, 3. ],</span>
<span class="c1">##        [3. , 3. , 1. , 1. ]])</span>
</pre></div>
</div>
<p>computes the ranks of elements in each column.</p>
<p>Also note that a few functions have the default argument
<code class="docutils literal notranslate"><span class="pre">axis=-1</span></code>, which means that they  are applied
along the last (i.e., columns in the matrix case) axis:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1"># axis=1 here</span>
<span class="c1">## array([[ 0.4, -0.2,  0. ],</span>
<span class="c1">##        [ 0.2,  0.2,  0.3],</span>
<span class="c1">##        [ 0. , -0.6, -0.1]])</span>
</pre></div>
</div>
<p>However, the aforementioned <strong class="command">numpy.mean</strong> is
amongst the many exceptions to this rule.</p>
<p>Compare the above with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">## array([[-0.2, -0.4,  0. ,  0.3],</span>
<span class="c1">##        [ 0.8,  0.6, -0.2, -0.6]])</span>
</pre></div>
</div>
<p>which gives the iterated differences for
each column separately (along the rows).</p>
<p>If a function (built-in or custom) in not equipped with the <code class="docutils literal notranslate"><span class="pre">axis</span></code>
argument and – instead – it was designed to work
with individual vectors,
we can propagate it over all the rows or columns
by calling <strong class="command">numpy.apply_along_axis</strong>.</p>
<p>For instance, here is another (have we solved the suggested
exercise?) way to compute the column z-scores:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">standardise</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">standardise</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">## array([[-0.39,  0.27,  0.71, -0.  ],</span>
<span class="c1">##        [-0.98, -1.34,  0.71,  1.22],</span>
<span class="c1">##        [ 1.37,  1.07, -1.41, -1.22]])</span>
</pre></div>
</div>
</div>
<div class="section" id="filtering">
<span id="sec-matrix-indexing"></span><h2><span class="section-number">9.5. </span>Filtering<a class="headerlink" href="#filtering" title="Permalink to this headline"></a></h2>
<p>Recall that for 1-dimensional arrays we have
4 possible choices of an indexer
(i.e., where performing filtering like <code class="docutils literal notranslate"><span class="pre">x[i]</span></code>):</p>
<ul class="simple">
<li><p>scalar (extracts a single element),</p></li>
<li><p>slice (selects a regular subsequence, e.g., every 2nd element
or the first 6 items; returns a <em>view</em> on existing data  – it does
not make an independent copy of the subsetted elements),</p></li>
<li><p>integer vector (selects elements at given indices),</p></li>
<li><p>logical vector (select elements that correspond to
<code class="docutils literal notranslate"><span class="pre">True</span></code> in the indexer).</p></li>
</ul>
<p>Matrices are two-dimensional arrays, and hence
subsetting thereof will require two indexes:
we will thus be writing <code class="docutils literal notranslate"><span class="pre">A[i,</span> <span class="pre">j]</span></code>
to select rows given by <code class="docutils literal notranslate"><span class="pre">i</span></code> and columns given by <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> can be one of the four above types,
so we at least 10 different cases to consider
(skipping the symmetric ones).</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Generally:</p>
<ul class="simple">
<li><p>each scalar indexer reduces the dimensionality of the
subsetted object by 1;</p></li>
<li><p>slice-slice and slice-scalar indexing returns a view on
the existing array, so we need to be careful when modifying
the resulting object;</p></li>
<li><p>usually, indexing returns a submatrix (subblock),
which is a combination of elements at given rows and columns,
but two flat-vector indexers are vectorised elementwisely instead;</p></li>
<li><p>indexing with two integer or logical vectors at the same time
should be avoided.</p></li>
</ul>
</div>
<p>Let us look at all the possible scenarios in greater detail.</p>
<div class="section" id="slice-based-indexing">
<h3><span class="section-number">9.5.1. </span>Slice-Based Indexing<a class="headerlink" href="#slice-based-indexing" title="Permalink to this headline"></a></h3>
<p>Our favourite example matrix again:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="p">])</span>
</pre></div>
</div>
<p>Indexing based on two slices selects a submatrix:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>
<span class="c1">## array([[0.4],</span>
<span class="c1">##        [0.1]])</span>
</pre></div>
</div>
<p>gives every second row and skips first three columns.
Note that the result is still a matrix.</p>
<p>An empty slice selects all elements on the corresponding axis, therefore:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># all rows, reversed columns</span>
<span class="c1">## array([[0.4, 0.4, 0.6, 0.2],</span>
<span class="c1">##        [0.7, 0.4, 0.2, 0. ],</span>
<span class="c1">##        [0.1, 0.2, 0.8, 0.8]])</span>
</pre></div>
</div>
<p>simply reverses the order of columns.</p>
</div>
<div class="section" id="scalar-based-indexing">
<h3><span class="section-number">9.5.2. </span>Scalar-Based Indexing<a class="headerlink" href="#scalar-based-indexing" title="Permalink to this headline"></a></h3>
<p>Indexing by a scalar selects a given row or column,
reducing the dimensionality of the output object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
<span class="c1">## array([0. , 0.2, 0.4, 0.7])</span>
</pre></div>
</div>
<p>selects the 2nd row and gives a flat vector.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="c1">## 0.4</span>
</pre></div>
</div>
<p>yields the element in the first row and last column.</p>
<p>However, we can always use the <strong class="command">reshape</strong> method to
convert the resulting object back to a matrix.</p>
</div>
<div class="section" id="mixing-vectors-with-scalars-or-slices">
<h3><span class="section-number">9.5.3. </span>Mixing Vectors with Scalars or Slices<a class="headerlink" href="#mixing-vectors-with-scalars-or-slices" title="Permalink to this headline"></a></h3>
<p>A logical and integer vector-like object can also be used
for element selection.
If the other indexer is a slice or a scalar, the result is
quite predictable, for instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
<span class="c1">## array([[0.4, 0.4, 0.6, 0.2],</span>
<span class="c1">##        [0.1, 0.2, 0.8, 0.8],</span>
<span class="c1">##        [0.4, 0.4, 0.6, 0.2]])</span>
</pre></div>
</div>
<p>selects the first, the last, and the first row again
and reverses the order of columns.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">,</span> <span class="p">:</span> <span class="p">]</span>
<span class="c1">## array([[0.2, 0.6, 0.4, 0.4],</span>
<span class="c1">##        [0.8, 0.8, 0.2, 0.1]])</span>
</pre></div>
</div>
<p>selects rows such that in the first column the values
are greater than 0.1.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.35</span><span class="p">,</span> <span class="p">:</span> <span class="p">]</span>
<span class="c1">## array([[0.2, 0.6, 0.4, 0.4],</span>
<span class="c1">##        [0.8, 0.8, 0.2, 0.1]])</span>
</pre></div>
</div>
<p>selects the rows whose mean is greater than 0.35.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">:</span> <span class="p">]</span>
<span class="c1">## array([[0. , 0.2, 0.4, 0.7],</span>
<span class="c1">##        [0.2, 0.6, 0.4, 0.4],</span>
<span class="c1">##        [0.8, 0.8, 0.2, 0.1]])</span>
</pre></div>
</div>
<p>orders the matrix with respect to the values in the first
row (all rows permuted in the same way, together).</p>
<div class="proof proof-type-exercise" id="id4">

    <div class="proof-title">
        <span class="proof-type">Exercise 9.4</span>
        
    </div><div class="proof-content">
<p>In the
<a class="reference external" href="https://raw.githubusercontent.com/gagolews/teaching_data/master/marek/nhanes_adult_female_bmx_2020.csv"><code class="docutils literal notranslate"><span class="pre">nhanes_adult_female_bmx_2020</span></code></a> dataset,
select all the participants whose heights is within their
mean ± 2 standard deviations.</p>
</div></div></div>
<div class="section" id="two-vectors-as-indexers">
<h3><span class="section-number">9.5.4. </span>Two Vectors as Indexers (*)<a class="headerlink" href="#two-vectors-as-indexers" title="Permalink to this headline"></a></h3>
<p>With two vectors (logical or integer) things are a tad more
horrible, as in this case not only some
form <em>shape broadcasting</em> comes into play
but also all the headache-inducing exceptions
listed in the perhaps not the most clearly written
<a class="reference external" href="https://numpy.org/doc/stable/user/basics.indexing.html">Advanced Indexing</a>
section of the <strong class="program">numpy</strong> manual.
Cheer up, however, things in <strong class="program">pandas</strong> are much worse
(see <a class="reference internal" href="410-dataframe.html#sec-df-indexing"><span class="std std-numref">Section 11.5</span></a>).</p>
<p>For the sake of our maintaining sanity, in practice it is best
to stick only to the scenarios below and be extra careful
when using two vector indexers.</p>
<p>For two flat integer indexers, we pick elementwisely:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="p">]</span>
<span class="c1">## array([0.6, 0.2, 0.2, 0.2, 0.6])</span>
</pre></div>
</div>
<p>yields <code class="docutils literal notranslate"><span class="pre">A[0,</span> <span class="pre">1]</span></code>, <code class="docutils literal notranslate"><span class="pre">A[-1,</span> <span class="pre">2]</span></code>, <code class="docutils literal notranslate"><span class="pre">A[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">A[2,</span> <span class="pre">2]</span></code>, and <code class="docutils literal notranslate"><span class="pre">A[0,</span> <span class="pre">1]</span></code>.</p>
<p>In order to select a submatrix using integer indexes,
it is best to make sure that the first indexer is a column vector,
and the second is a row vector (or some object like the
two said ones, e.g., compatible lists of lists).
Further, if indexing involves logical vectors,
it is best to convert them to integer ones first
(e.g., by calling <strong class="command">numpy.where</strong>).</p>
<p>The above transformations can be done automatically
via the <strong class="command">numpy.ix_</strong> function, which is always the safest choice:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.35</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="p">]</span>
<span class="c1">## array([[0.2, 0.4, 0.4, 0.2],</span>
<span class="c1">##        [0.8, 0.2, 0.1, 0.8]])</span>
</pre></div>
</div>
<p>Alternatively, we can always apply indexing twice instead
(which we will anyway be forced to do in <strong class="program">pandas</strong>
whenever selecting rows by number and columns by names is required).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.45</span><span class="p">,</span> <span class="p">:][:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="c1">## array([[0.8, 0.2, 0.1, 0.8]])</span>
</pre></div>
</div>
</div>
<div class="section" id="views-on-existing-arrays">
<h3><span class="section-number">9.5.5. </span>Views on Existing Arrays (*)<a class="headerlink" href="#views-on-existing-arrays" title="Permalink to this headline"></a></h3>
<p>Only indexing involving two slices or a slice and a scalar returns a
<a class="reference external" href="https://numpy.org/devdocs/user/basics.copies.html">view</a>
on an existing array.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="n">B</span>
<span class="c1">## array([[0.2, 0.4],</span>
<span class="c1">##        [0. , 0.4],</span>
<span class="c1">##        [0.8, 0.2]])</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> share memory. Therefore, by modifying <code class="docutils literal notranslate"><span class="pre">B</span></code>
in-place, e.g.,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<p>the changes will be visible in <code class="docutils literal notranslate"><span class="pre">A</span></code> as well:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>
<span class="c1">## array([[-0.2,  0.6, -0.4,  0.4],</span>
<span class="c1">##        [-0. ,  0.2, -0.4,  0.7],</span>
<span class="c1">##        [-0.8,  0.8, -0.2,  0.1]])</span>
</pre></div>
</div>
<p>This is time and memory efficient, but
might lead to some unexpected results if we are not
focused enough. We have been warned.</p>
</div>
</div>
<div class="section" id="exercises">
<h2><span class="section-number">9.6. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline"></a></h2>
<div class="proof proof-type-exercise" id="id5">

    <div class="proof-title">
        <span class="proof-type">Exercise 9.5</span>
        
    </div><div class="proof-content">
<p>Does <strong class="command">numpy.mean</strong><strong class="command">(A, axis=0)</strong>
compute rowwise or columnwise means?</p>
</div></div><div class="proof proof-type-exercise" id="id6">

    <div class="proof-title">
        <span class="proof-type">Exercise 9.6</span>
        
    </div><div class="proof-content">
<p>How does shape broadcasting work? List the most common pairs of shape cases
when performing arithmetic operations.</p>
</div></div><div class="proof proof-type-exercise" id="id7">

    <div class="proof-title">
        <span class="proof-type">Exercise 9.7</span>
        
    </div><div class="proof-content">
<p>What are the possible matrix indexing schemes
and how do they behave?</p>
</div></div><div class="proof proof-type-exercise" id="id8">

    <div class="proof-title">
        <span class="proof-type">Exercise 9.8</span>
        
    </div><div class="proof-content">
<p>Which kinds of matrix indexers return a view on an existing array?</p>
</div></div><div class="proof proof-type-exercise" id="id9">

    <div class="proof-title">
        <span class="proof-type">Exercise 9.9</span>
        
    </div><div class="proof-content">
<p>(*) How to select a submatrix comprised of
the first and the last row and the first and the last column?</p>
</div></div></div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="330-corelation.html" class="btn btn-neutral float-right" title="10. 🚧 Exploring Relationships Between Variables" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="310-matrix.html" class="btn btn-neutral float-left" title="8. Multidimensional Numeric Data at a Glance" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Marek Gagolewski. Licensed under CC BY-NC-ND 4.0.
      <span class="lastupdated">
        Last updated on 2022-04-13T15:58:00+1000.
      </span>
    Built with <a href="https://sphinx-doc.org/">Sphinx</a>
    and a customised <a href="https://github.com/rtfd/sphinx_rtd_theme">rtd</a> theme.
    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>