<!DOCTYPE html>


<html class="writer-html5" lang="en" >
<!-- Copyright (C) 2020-2022, Marek Gagolewski <https://www.gagolewski.com> -->

<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>8. Processing Multidimensional Data &mdash; Minimalist Data Wrangling with Python by Marek Gagolewski</title>
  

  
  
  <script async defer src="https://buttons.github.io/buttons.js"></script>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/proof.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  
    <link rel="canonical" href="https://datawranglingpy.gagolewski.com/chapter/320-transform-matrix.html" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/proof.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="9. Exploring Relationships Between Variables" href="330-relationship.html" />
    <link rel="prev" title="7. Multidimensional Numeric Data at a Glance" href="310-matrix.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html"> Minimalist Data Wrangling with Python [v0.5.2]
          

          
          </a>

          <div class="version">
          by <a style="color: inherit" href="https://www.gagolewski.com">Marek Gagolewski</a>
          </div>

<!--
          
            
            
              <div class="version">
                by Marek Gagolewski
              </div>
            
          
-->

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search phrase..." />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Start Here</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="000-preface.html">Preface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introducing Python</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="110-setup.html">1. Getting Started with Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="120-scalar.html">2. Scalar Types and Control Structures in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="130-sequential.html">3. Sequential and Other Types in Python</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Unidimensional Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="210-vector.html">4. Unidimensional Numeric Data and Their Empirical Distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="220-transform-vector.html">5. Processing Unidimensional Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="230-distribution.html">6. Continuous Probability Distributions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Multidimensional Data</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="310-matrix.html">7. Multidimensional Numeric Data at a Glance</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. Processing Multidimensional Data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#from-vectors-to-matrices">8.1. From Vectors to Matrices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vectorised-mathematical-functions">8.1.1. Vectorised Mathematical Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#componentwise-aggregation">8.1.2. Componentwise Aggregation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arithmetic-logical-and-comparison-operations">8.1.3. Arithmetic, Logical, and Comparison Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#matrix-vs-scalar">8.1.3.1. Matrix vs Scalar</a></li>
<li class="toctree-l4"><a class="reference internal" href="#matrix-vs-matrix">8.1.3.2. Matrix vs Matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="#matrix-vs-any-vector">8.1.3.3. Matrix vs Any Vector</a></li>
<li class="toctree-l4"><a class="reference internal" href="#row-vector-vs-column-vector">8.1.3.4. Row Vector vs Column Vector (*)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#other-row-and-column-transforms">8.1.4. Other Row and Column Transforms (*)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#indexing-matrices">8.2. Indexing Matrices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#slice-based-indexing">8.2.1. Slice-Based Indexing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scalar-based-indexing">8.2.2. Scalar-Based Indexing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-boolean-integer-vector-and-scalar-slice-indexers">8.2.3. Mixed Boolean/Integer Vector and Scalar/Slice Indexers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#two-vectors-as-indexers">8.2.4. Two Vectors as Indexers (*)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#views-on-existing-arrays">8.2.5. Views on Existing Arrays (*)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-and-modifying-rows-and-columns">8.2.6. Adding and Modifying Rows and Columns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#matrix-multiplication-dot-products-and-the-euclidean-norm">8.3. Matrix Multiplication, Dot Products, and the Euclidean Norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pairwise-distances-and-related-methods">8.4. Pairwise Distances and Related Methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-euclidean-metric">8.4.1. The Euclidean Metric</a></li>
<li class="toctree-l3"><a class="reference internal" href="#centroids">8.4.2. Centroids</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multidimensional-dispersion-and-other-aggregates">8.4.3. Multidimensional Dispersion and Other Aggregates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fixed-radius-and-k-nearest-neighbour-search">8.4.4. Fixed-Radius and <em>K</em>-Nearest Neighbour Search</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spatial-search-with-k-d-trees">8.4.5. Spatial Search with <em>K</em>-d Trees</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">8.5. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="330-relationship.html">9. Exploring Relationships Between Variables</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Heterogeneous Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="410-data-frame.html">10. Introducing Data Frames</a></li>
<li class="toctree-l1"><a class="reference internal" href="420-categorical.html">11. Handling Categorical Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="430-group-by.html">12. Processing Data in Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="440-sql.html">13. Accessing Databases (An Interlude)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Data Types</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="510-text.html">14. Text Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="520-missingness.html">15. Missing, Censored, and Questionable Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="530-time-series.html">16. Time Series</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="998-changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="999-bibliography.html">Bibliography</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://datawranglingpy.gagolewski.com/datawranglingpy.pdf">This Book in PDF</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/datawranglingpy/blob/master/CODE_OF_CONDUCT.md">Report Bugs or Typos</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/teaching_data">Datasets</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.gagolewski.com">Author</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Minimalist Data Wrangling with Python [v0.5.2]</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          



















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">8. </span>Processing Multidimensional Data</li>
    
    
      <li class="wy-breadcrumbs-aside">

        
        
        <a class="github-button" href="https://github.com/gagolews/datawranglingpy" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star gagolews/datawranglingpy on GitHub">Star</a>
        


        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="330-relationship.html" class="btn btn-neutral float-right" title="9. Exploring Relationships Between Variables" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      
      
        <a href="310-matrix.html" class="btn btn-neutral float-left" title="7. Multidimensional Numeric Data at a Glance" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="tex2jax_ignore mathjax_ignore section" id="processing-multidimensional-data">
<span id="chap-transform-matrix"></span><h1><span class="section-number">8. </span>Processing Multidimensional Data<a class="headerlink" href="#processing-multidimensional-data" title="Permalink to this headline"></a></h1>
<blockquote>
<div><p><em>The online version of the open access textbook</em> Minimalist Data
Wrangling with Python <em>by <a class="reference external" href="https://www.gagolewski.com">Marek Gagolewski</a>
is, and will remain, freely available for everyone’s enjoyment
(also in <a class="reference external" href="https://datawranglingpy.gagolewski.com/datawranglingpy.pdf">PDF</a>).
Any <a class="reference external" href="https://github.com/gagolews/datawranglingpy/blob/master/CODE_OF_CONDUCT.md">bug/typos reports/fixes</a>
are appreciated. Although available online, this is a whole course,
and should be read from the beginning to the end. In particular,
refer to the <a class="reference internal" href="000-preface.html#chap-preface"><span class="std std-ref">Preface</span></a> for general introductory remarks.</em></p>
</div></blockquote>
<div class="section" id="from-vectors-to-matrices">
<h2><span class="section-number">8.1. </span>From Vectors to Matrices<a class="headerlink" href="#from-vectors-to-matrices" title="Permalink to this headline"></a></h2>
<p>First, let us study how the vector operations
that we discussed in, amongst others,
<a class="reference internal" href="220-transform-vector.html#chap-transform-vector"><span class="std std-numref">Chapter 5</span></a>
can be extended to matrices.
In many cases, we will end up applying the same transform either
on every matrix element separately, or on each row or column.
They are all a brilliant example of the <em>write less, do more</em> principle
in practice.</p>
<div class="section" id="vectorised-mathematical-functions">
<h3><span class="section-number">8.1.1. </span>Vectorised Mathematical Functions<a class="headerlink" href="#vectorised-mathematical-functions" title="Permalink to this headline"></a></h3>
<p>Applying vectorised functions such
as <strong class="command">numpy.round</strong>, <strong class="command">numpy.log</strong>, and <strong class="command">numpy.exp</strong>
returns an array of the same shape, with all elements
transformed accordingly.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="p">])</span>  <span class="c1"># example matrix that we will be using below</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="c1">## array([[0.04, 0.36, 0.16, 0.16],</span>
<span class="c1">##        [0.  , 0.04, 0.16, 0.49],</span>
<span class="c1">##        [0.64, 0.64, 0.04, 0.01]])</span>
</pre></div>
</div>
<p>takes the square of every element.</p>
<p>More generally, we will be denoting such operations with:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
f(\mathbf{X})=
\left[
\begin{array}{cccc}
f(x_{1,1}) &amp; f(x_{1,2}) &amp; \cdots &amp; f(x_{1,m}) \\
f(x_{2,1}) &amp; f(x_{2,2}) &amp; \cdots &amp; f(x_{2,m}) \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
f(x_{n,1}) &amp; f(x_{n,2}) &amp; \cdots &amp; f(x_{n,m}) \\
\end{array}
\right].
\end{split}\]</div>
</div>
<div class="section" id="componentwise-aggregation">
<h3><span class="section-number">8.1.2. </span>Componentwise Aggregation<a class="headerlink" href="#componentwise-aggregation" title="Permalink to this headline"></a></h3>
<p>Unidimensional aggregation functions
(e.g., <strong class="command">numpy.mean</strong>, <strong class="command">numpy.quantile</strong>)
can be applied to summarise:</p>
<ul class="simple">
<li><p>data in each row (<code class="docutils literal notranslate"><span class="pre">axis=1</span></code>),</p></li>
<li><p>data in each column (<code class="docutils literal notranslate"><span class="pre">axis=0</span></code>),</p></li>
</ul>
<p>as well as:</p>
<ul class="simple">
<li><p>all data into a single number (<code class="docutils literal notranslate"><span class="pre">axis=None</span></code>, being the default),</p></li>
</ul>
<p>Here are the examples corresponding to the above cases:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="c1">## 0.39999999999999997</span>
<span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([0.4  , 0.325, 0.475])</span>
<span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">## array([0.33333333, 0.53333333, 0.33333333, 0.4       ])</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Let us repeat, <code class="docutils literal notranslate"><span class="pre">axis=1</span></code> does not mean
that we get the column means (even though
columns constitute the 2nd axis, and we count starting at 0).
It denotes the axis <em>along</em> which the matrix is sliced.
Sadly, even yours truly sometimes does not get it right.</p>
</div>
<div class="proof proof-type-exercise" id="id6">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.1</span>
        
    </div><div class="proof-content">
<p>Given the <a class="reference external" href="https://raw.githubusercontent.com/gagolews/teaching_data/master/marek/nhanes_adult_female_bmx_2020.csv"><code class="docutils literal notranslate"><span class="pre">nhanes_adult_female_bmx_2020</span></code></a>
dataset, compute the mean, standard deviation, minimum,
and maximum of each body measurement.</p>
</div></div><p>We will get back to the topic of the aggregation of
multidimensional data in <a class="reference internal" href="#sec-centroid"><span class="std std-numref">Section 8.4.2</span></a>
and <a class="reference internal" href="#sec-aggmultidim"><span class="std std-numref">Section 8.4.3</span></a>.</p>
</div>
<div class="section" id="arithmetic-logical-and-comparison-operations">
<h3><span class="section-number">8.1.3. </span>Arithmetic, Logical, and Comparison Operations<a class="headerlink" href="#arithmetic-logical-and-comparison-operations" title="Permalink to this headline"></a></h3>
<p>Recall that for vectors, binary operators
such as `<strong class="command">+</strong>`, `<strong class="command">*</strong>`, `<strong class="command">==</strong>`,
`<strong class="command">&lt;=</strong>`, and `<strong class="command">&amp;</strong>`
and similar elementwise functions (e.g., <strong class="command">numpy.minimum</strong>)
can be applied if both inputs are of the same length,
for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="c1">## array([   7,  -60,  200, 8000])</span>
</pre></div>
</div>
<p>Alternatively, one input can be a scalar:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">])</span> <span class="o">*</span> <span class="o">-</span><span class="mi">3</span>
<span class="c1">## array([   -3,   -30,  -300, -3000])</span>
</pre></div>
</div>
<p>More generally, a set of rules referred in the
<strong class="program">numpy</strong> manual to as
<a class="reference external" href="https://numpy.org/devdocs/user/basics.broadcasting.html"><em>broadcasting</em></a>
describes how this package handles arrays of different shapes.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Generally, for two matrices, their column/row numbers much match
or be equal to 1.
Also, if one operand is a 1-dimensional array, it will be promoted
to a row vector.</p>
</div>
<p>Let us explore all the possible cases.</p>
<div class="section" id="matrix-vs-scalar">
<h4><span class="section-number">8.1.3.1. </span>Matrix vs Scalar<a class="headerlink" href="#matrix-vs-scalar" title="Permalink to this headline"></a></h4>
<p>If one operand is a scalar, then it is going to be propagated
over all matrix elements, for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">A</span>
<span class="c1">## array([[-0.2, -0.6, -0.4, -0.4],</span>
<span class="c1">##        [-0. , -0.2, -0.4, -0.7],</span>
<span class="c1">##        [-0.8, -0.8, -0.2, -0.1]])</span>
</pre></div>
</div>
<p>changes the sign of every element, which is,
mathematically,
an instance of multiplying a matrix <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> by a scalar <span class="math notranslate nohighlight">\(c\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}
c\mathbf{X}=
\left[
\begin{array}{cccc}
cx_{1,1} &amp; cx_{1,2} &amp; \cdots &amp; cx_{1,m} \\
cx_{2,1} &amp; cx_{2,2} &amp; \cdots &amp; cx_{2,m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
cx_{n,1} &amp; cx_{n,2} &amp; \cdots &amp; cx_{n,m} \\
\end{array}
\right].
\end{split}\]</div>
<p>Furthermore:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="o">**</span><span class="mi">2</span>
<span class="c1">## array([[0.04, 0.36, 0.16, 0.16],</span>
<span class="c1">##        [0.  , 0.04, 0.16, 0.49],</span>
<span class="c1">##        [0.64, 0.64, 0.04, 0.01]])</span>
</pre></div>
</div>
<p>takes the square of each element
(this is not the same as matrix-multiply by itself
which we cover in the matrix algebra section).</p>
<p>Also:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">&gt;=</span> <span class="mf">0.25</span>
<span class="c1">## array([[False,  True,  True,  True],</span>
<span class="c1">##        [False, False,  True,  True],</span>
<span class="c1">##        [ True,  True, False, False]])</span>
</pre></div>
</div>
<p>compares each element to 0.25.</p>
</div>
<div class="section" id="matrix-vs-matrix">
<h4><span class="section-number">8.1.3.2. </span>Matrix vs Matrix<a class="headerlink" href="#matrix-vs-matrix" title="Permalink to this headline"></a></h4>
<p>For two matrices of identical sizes, we will be
acting on the corresponding elements:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># just an example</span>
<span class="n">B</span>  <span class="c1"># a lower triangular 0-1 matrix</span>
<span class="c1">## array([[1., 0., 0., 0.],</span>
<span class="c1">##        [1., 1., 0., 0.],</span>
<span class="c1">##        [1., 1., 1., 0.]])</span>
</pre></div>
</div>
<p>And now:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">*</span> <span class="n">B</span>
<span class="c1">## array([[0.2, 0. , 0. , 0. ],</span>
<span class="c1">##        [0. , 0.2, 0. , 0. ],</span>
<span class="c1">##        [0.8, 0.8, 0.2, 0. ]])</span>
</pre></div>
</div>
<p>multiplies each <span class="math notranslate nohighlight">\(a_{i,j}\)</span> by the corresponding <span class="math notranslate nohighlight">\(b_{i,j}\)</span>.</p>
<p>This extends on the idea from algebra that given
<span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> with <em>n</em> rows and <em>m</em> columns each,
the result of <span class="math notranslate nohighlight">\(+\)</span> (or <span class="math notranslate nohighlight">\(-\)</span>) would be for instance:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{A} + \mathbf{B}=
\left[
\begin{array}{cccc}
a_{1,1}+b_{1,1} &amp; a_{1,2}+b_{1,2} &amp; \cdots &amp; a_{1,m}+b_{1,m} \\
a_{2,1}+b_{2,1} &amp; a_{2,2}+b_{1,2} &amp; \cdots &amp; a_{2,m}+b_{2,m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{n,1}+b_{n,1} &amp; a_{n,2}+b_{n,2} &amp; \cdots &amp; a_{n,m}+b_{n,m} \\
\end{array}
\right].
\end{split}\]</div>
<p>Thanks to the matrix-matrix and matrix-scalar operations
we can perform various tests on an per-element basis, e.g.,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;=</span> <span class="mf">0.25</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A</span> <span class="o">&lt;=</span> <span class="mf">0.75</span><span class="p">)</span>  <span class="c1"># logical matrix &amp; logical matrix</span>
<span class="c1">## array([[False,  True,  True,  True],</span>
<span class="c1">##        [False, False,  True,  True],</span>
<span class="c1">##        [False, False, False, False]])</span>
</pre></div>
</div>
<div class="proof proof-type-example" id="id7">

    <div class="proof-title">
        <span class="proof-type">Example 8.2</span>
        
    </div><div class="proof-content">
<p>(*)
<a class="reference internal" href="#fig-ex-contourf"><span class="std std-numref">Figure 8.1</span></a> depicts a (filled) contour plot
of the Himmelblau’s function, <span class="math notranslate nohighlight">\(f(x,y)=(x^{2}+y-11)^{2}+(x+y^{2}-7)^{2}\)</span>,
for <span class="math notranslate nohighlight">\(x\in[-5, 5]\)</span> and <span class="math notranslate nohighlight">\(y\in[-4, 4]\)</span>.
In order to draw it, we have probed 250 points from the two said
ranges and called <strong class="command">numpy.meshgrid</strong> to generate
two matrices, both of shape 250 by 250,
giving the x- and y-coordinates of all the points on
the corresponding a two-dimensional grid.
Thanks to this, we were able to use vectorised mathematical operations
to compute the values of <span class="math notranslate nohighlight">\(f\)</span> thereon.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="n">xg</span><span class="p">,</span> <span class="n">yg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">xg</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yg</span> <span class="o">-</span> <span class="mi">11</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">xg</span> <span class="o">+</span> <span class="n">yg</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">CS</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">250</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clabel</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-default" id="id8">
<span id="fig-ex-contourf"></span><img alt="../_images/ex-contourf-1.png" src="../_images/ex-contourf-1.png" />
<p class="caption"><span class="caption-number">Figure 8.1 </span><span class="caption-text">An example filled contour plot with additional labelled contour lines</span><a class="headerlink" href="#id8" title="Permalink to this image"></a></p>
</div>
<p>In order to understand the result generated by
<strong class="command">numpy.meshgrid</strong> better here are the outputs generated
by it for a smaller number of probe points:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">xg</span><span class="p">,</span> <span class="n">yg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">xg</span>
<span class="c1">## array([[-5.,  0.,  5.],</span>
<span class="c1">##        [-5.,  0.,  5.],</span>
<span class="c1">##        [-5.,  0.,  5.],</span>
<span class="c1">##        [-5.,  0.,  5.],</span>
<span class="c1">##        [-5.,  0.,  5.]])</span>
</pre></div>
</div>
<p>Here, each column is the same.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">yg</span>
<span class="c1">## array([[-4., -4., -4.],</span>
<span class="c1">##        [-2., -2., -2.],</span>
<span class="c1">##        [ 0.,  0.,  0.],</span>
<span class="c1">##        [ 2.,  2.,  2.],</span>
<span class="c1">##        [ 4.,  4.,  4.]])</span>
</pre></div>
</div>
<p>In this case, each row is identical. Thanks to this, calling:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">xg</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yg</span> <span class="o">-</span> <span class="mi">11</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">xg</span> <span class="o">+</span> <span class="n">yg</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="c1">## array([[116., 306., 296.],</span>
<span class="c1">##        [208., 178., 148.],</span>
<span class="c1">##        [340., 170., 200.],</span>
<span class="c1">##        [320.,  90., 260.],</span>
<span class="c1">##        [340., 130., 520.]])</span>
</pre></div>
</div>
<p>gives a matrix <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> such that
<span class="math notranslate nohighlight">\(z_{i,j}\)</span> is generated by considering the <span class="math notranslate nohighlight">\(i\)</span>-th element in <code class="docutils literal notranslate"><span class="pre">y</span></code>
and the <span class="math notranslate nohighlight">\(j\)</span>-th item in <code class="docutils literal notranslate"><span class="pre">x</span></code>, which is exactly what we have desired.</p>
</div></div></div>
<div class="section" id="matrix-vs-any-vector">
<h4><span class="section-number">8.1.3.3. </span>Matrix vs Any Vector<a class="headerlink" href="#matrix-vs-any-vector" title="Permalink to this headline"></a></h4>
<p>An <em>n×m</em> matrix can also be combined with
an <em>n×1</em> column vector:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[ 0.2,  0.6,  0.4,  0.4],</span>
<span class="c1">##        [ 0. ,  2. ,  4. ,  7. ],</span>
<span class="c1">##        [80. , 80. , 20. , 10. ]])</span>
</pre></div>
</div>
<p>The above propagated the column vector over all columns (left to right).</p>
<p>Similarly, combining with an <em>1×m</em> row vector:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[1.2, 2.6, 3.4, 4.4],</span>
<span class="c1">##        [1. , 2.2, 3.4, 4.7],</span>
<span class="c1">##        [1.8, 2.8, 3.2, 4.1]])</span>
</pre></div>
</div>
<p>recycles the row vector over all rows (top to bottom).</p>
<p>If one operand is a 1-dimensional array or a list of length
<em>m</em>, it will be treated as a row vector.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">## array([[-0.133,  0.067,  0.067, -0.   ],</span>
<span class="c1">##        [-0.333, -0.333,  0.067,  0.3  ],</span>
<span class="c1">##        [ 0.467,  0.267, -0.133, -0.3  ]])</span>
</pre></div>
</div>
<p>This resulted in each column mean’s being 0. An explicit <code class="docutils literal notranslate"><span class="pre">.reshape(1,</span> <span class="pre">-1)</span></code>
was not necessary.</p>
<p>Mathematically, although it is not necessarily a standard
notation, we will allow adding and subtracting row vectors
from matrices of compatible sizes:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{X}+\mathbf{t}=
\left[
\begin{array}{cccc}
x_{1,1} + t_1 &amp; x_{1,2} + t_2 &amp; \dots &amp; x_{1,m} + t_m \\
x_{2,1} + t_1 &amp; x_{2,2} + t_2 &amp; \dots &amp; x_{2,m} + t_m \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{n,1} + t_1 &amp; x_{n,2} + t_2 &amp; \dots &amp; x_{n,m} + t_m \\
\end{array}
\right].
\end{split}\]</div>
<p>This corresponds to shifting (translating) every row
in the matrix.</p>
<p>However, subtracting the row means already requires
some extra labour:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[-0.2  ,  0.2  ,  0.   ,  0.   ],</span>
<span class="c1">##        [-0.325, -0.125,  0.075,  0.375],</span>
<span class="c1">##        [ 0.325,  0.325, -0.275, -0.375]])</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-</span> <span class="pre">np.mean(A,</span> <span class="pre">axis=1)</span></code> would raise an exception.</p>
<div class="proof proof-type-exercise" id="id9">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.3</span>
        
    </div><div class="proof-content">
<p>Standardise, normalise, and min-max scale
each column in the <a class="reference external" href="https://raw.githubusercontent.com/gagolews/teaching_data/master/marek/nhanes_adult_female_bmx_2020.csv"><code class="docutils literal notranslate"><span class="pre">nhanes_adult_female_bmx_2020.csv</span></code></a>
dataset using a single line of code.</p>
</div></div></div>
<div class="section" id="row-vector-vs-column-vector">
<h4><span class="section-number">8.1.3.4. </span>Row Vector vs Column Vector (*)<a class="headerlink" href="#row-vector-vs-column-vector" title="Permalink to this headline"></a></h4>
<p>As a bonus, let us quickly mention that
a row vector combined with a column vector results
in an operation’s being performed on each <em>combination</em>
of <em>all</em> pairs of elements in the two arrays
(i.e., the cross-product; not just the <em>corresponding</em> pairs).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[  1,   2,   3,   4,   5,   6,   7],</span>
<span class="c1">##        [ 10,  20,  30,  40,  50,  60,  70],</span>
<span class="c1">##        [100, 200, 300, 400, 500, 600, 700]])</span>
</pre></div>
</div>
<div class="proof proof-type-exercise" id="id10">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.4</span>
        
    </div><div class="proof-content">
<p>Check out that
<strong class="command">numpy.nonzero</strong> relies on similar shape broadcasting rules
as the binary operators we have discussed here,
however, not with regards to all the 3 arguments.</p>
</div></div><div class="proof proof-type-example" id="id11">

    <div class="proof-title">
        <span class="proof-type">Example 8.5</span>
        
    </div><div class="proof-content">
<p>Himmelblau’s function in <a class="reference internal" href="#fig-ex-contourf"><span class="std std-numref">Figure 8.1</span></a> is only defined
by means of arithmetic operators, which all accept the kind of
shape broadcasting that we discuss in this section.
Therefore, calling <strong class="command">numpy.meshgrid</strong> in that example
was actually not necessary in order to evaluate <span class="math notranslate nohighlight">\(f\)</span>
on a grid of points:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">xg</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">yg</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="n">xg</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yg</span> <span class="o">-</span> <span class="mi">11</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">xg</span> <span class="o">+</span> <span class="n">yg</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="c1">## array([[116., 306., 296.],</span>
<span class="c1">##        [208., 178., 148.],</span>
<span class="c1">##        [340., 170., 200.],</span>
<span class="c1">##        [320.,  90., 260.],</span>
<span class="c1">##        [340., 130., 520.]])</span>
</pre></div>
</div>
<p>See also the <code class="docutils literal notranslate"><span class="pre">sparse</span></code> parameter in <strong class="command">numpy.meshgrid</strong>
and <a class="reference internal" href="430-group-by.html#fig-knn-class"><span class="std std-numref">Figure 12.9</span></a> where this function turns out useful after all.</p>
</div></div></div>
</div>
<div class="section" id="other-row-and-column-transforms">
<h3><span class="section-number">8.1.4. </span>Other Row and Column Transforms (*)<a class="headerlink" href="#other-row-and-column-transforms" title="Permalink to this headline"></a></h3>
<p>Some functions that we have already discussed in the previous part
of this course are  equipped with the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument, which
allows to process each row or column independently,
for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">## array([[0.2, 0.4, 0.4, 0.6],</span>
<span class="c1">##        [0. , 0.2, 0.4, 0.7],</span>
<span class="c1">##        [0.1, 0.2, 0.8, 0.8]])</span>
</pre></div>
</div>
<p>sorts every row (separately). Moreover:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">rankdata</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">## array([[2. , 2. , 2.5, 2. ],</span>
<span class="c1">##        [1. , 1. , 2.5, 3. ],</span>
<span class="c1">##        [3. , 3. , 1. , 1. ]])</span>
</pre></div>
</div>
<p>computes the ranks of elements in each column.</p>
<p>Also note that a few functions have the default argument
<code class="docutils literal notranslate"><span class="pre">axis=-1</span></code>, which means that they  are applied
along the last (i.e., columns in the matrix case) axis:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1"># axis=1 here</span>
<span class="c1">## array([[ 0.4, -0.2,  0. ],</span>
<span class="c1">##        [ 0.2,  0.2,  0.3],</span>
<span class="c1">##        [ 0. , -0.6, -0.1]])</span>
</pre></div>
</div>
<p>However, the aforementioned <strong class="command">numpy.mean</strong> is
amongst the many exceptions to this rule.</p>
<p>Compare the above with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">## array([[-0.2, -0.4,  0. ,  0.3],</span>
<span class="c1">##        [ 0.8,  0.6, -0.2, -0.6]])</span>
</pre></div>
</div>
<p>which gives the iterated differences for
each column separately (along the rows).</p>
<p>If a function (built-in or custom) in not equipped with the <code class="docutils literal notranslate"><span class="pre">axis</span></code>
argument and – instead – it was designed to work
with individual vectors,
we can propagate it over all the rows or columns
by calling <strong class="command">numpy.apply_along_axis</strong>.</p>
<p>For instance, here is another (have we solved the suggested
exercise?) way to compute the column z-scores:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">standardise</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">standardise</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">## array([[-0.39,  0.27,  0.71, -0.  ],</span>
<span class="c1">##        [-0.98, -1.34,  0.71,  1.22],</span>
<span class="c1">##        [ 1.37,  1.07, -1.41, -1.22]])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>(*)
Matrices are of course iterable (in the sense of <a class="reference internal" href="130-sequential.html#sec-iterable"><span class="std std-numref">Section 3.4</span></a>),
but in an interesting way. Namely, an iterator traverses through
each row in a matrix. Therefore, for example,
writing</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">A</span>  <span class="c1"># A has 3 rows</span>
</pre></div>
</div>
<p>creates three variables, each representing a separate row
in <code class="docutils literal notranslate"><span class="pre">A</span></code>, second of which being</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">r2</span>
<span class="c1">## array([0. , 0.2, 0.4, 0.7])</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="indexing-matrices">
<span id="sec-matrix-indexing"></span><h2><span class="section-number">8.2. </span>Indexing Matrices<a class="headerlink" href="#indexing-matrices" title="Permalink to this headline"></a></h2>
<p>Recall that for 1-dimensional arrays we have four possible choices
of indexers (i.e., where performing filtering like <code class="docutils literal notranslate"><span class="pre">x[i]</span></code>):</p>
<ul class="simple">
<li><p>scalar (extracts a single element),</p></li>
<li><p>slice (selects a regular subsequence, e.g., every 2nd element
or the first 6 items; returns a <em>view</em> on existing data  – it does
not make an independent copy of the subsetted elements),</p></li>
<li><p>integer vector (selects elements at given indices),</p></li>
<li><p>logical vector (select elements that correspond to
<code class="docutils literal notranslate"><span class="pre">True</span></code> in the indexer).</p></li>
</ul>
<p>Matrices are two-dimensional arrays, and hence
subsetting thereof will require two indexes:
we will thus be writing <code class="docutils literal notranslate"><span class="pre">A[i,</span> <span class="pre">j]</span></code>
to select rows given by <code class="docutils literal notranslate"><span class="pre">i</span></code> and columns given by <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> can be one of the four above types,
so we at least 10 different cases to consider
(skipping the symmetric ones).</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Generally:</p>
<ul class="simple">
<li><p>each scalar indexer reduces the dimensionality of the
subsetted object by 1;</p></li>
<li><p>slice-slice and slice-scalar indexing returns a view on
the existing array, so we need to be careful when modifying
the resulting object;</p></li>
<li><p>usually, indexing returns a submatrix (subblock),
which is a combination of elements at given rows and columns,
but two flat-vector indexers are vectorised elementwisely instead;</p></li>
<li><p>indexing with two integer or logical vectors at the same time
should be avoided.</p></li>
</ul>
</div>
<p>Let us look at all the possible scenarios in greater detail.</p>
<div class="section" id="slice-based-indexing">
<h3><span class="section-number">8.2.1. </span>Slice-Based Indexing<a class="headerlink" href="#slice-based-indexing" title="Permalink to this headline"></a></h3>
<p>Our favourite example matrix again:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="p">])</span>
</pre></div>
</div>
<p>Indexing based on two slices selects a submatrix:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>
<span class="c1">## array([[0.4],</span>
<span class="c1">##        [0.1]])</span>
</pre></div>
</div>
<p>gives every second row and skips first three columns.
Note that the result is still a matrix.</p>
<p>An empty slice selects all elements on the corresponding axis, therefore:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># all rows, reversed columns</span>
<span class="c1">## array([[0.4, 0.4, 0.6, 0.2],</span>
<span class="c1">##        [0.7, 0.4, 0.2, 0. ],</span>
<span class="c1">##        [0.1, 0.2, 0.8, 0.8]])</span>
</pre></div>
</div>
<p>simply reverses the order of columns.</p>
</div>
<div class="section" id="scalar-based-indexing">
<h3><span class="section-number">8.2.2. </span>Scalar-Based Indexing<a class="headerlink" href="#scalar-based-indexing" title="Permalink to this headline"></a></h3>
<p>Indexing by a scalar selects a given row or column,
reducing the dimensionality of the output object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
<span class="c1">## array([0. , 0.2, 0.4, 0.7])</span>
</pre></div>
</div>
<p>selects the 2nd row and gives a flat vector.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="c1">## 0.4</span>
</pre></div>
</div>
<p>yields the element in the first row and last column.</p>
<p>However, we can always use the <strong class="command">reshape</strong> method to
convert the resulting object back to a matrix.</p>
</div>
<div class="section" id="mixed-boolean-integer-vector-and-scalar-slice-indexers">
<h3><span class="section-number">8.2.3. </span>Mixed Boolean/Integer Vector and Scalar/Slice Indexers<a class="headerlink" href="#mixed-boolean-integer-vector-and-scalar-slice-indexers" title="Permalink to this headline"></a></h3>
<p>A logical and integer vector-like object can also be used
for element selection.
If the other indexer is a slice or a scalar, the result is
quite predictable, for instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
<span class="c1">## array([[0.4, 0.4, 0.6, 0.2],</span>
<span class="c1">##        [0.1, 0.2, 0.8, 0.8],</span>
<span class="c1">##        [0.4, 0.4, 0.6, 0.2]])</span>
</pre></div>
</div>
<p>selects the first, the last, and the first row again
and reverses the order of columns.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">,</span> <span class="p">:</span> <span class="p">]</span>
<span class="c1">## array([[0.2, 0.6, 0.4, 0.4],</span>
<span class="c1">##        [0.8, 0.8, 0.2, 0.1]])</span>
</pre></div>
</div>
<p>selects rows such that in the first column the values
are greater than 0.1.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.35</span><span class="p">,</span> <span class="p">:</span> <span class="p">]</span>
<span class="c1">## array([[0.2, 0.6, 0.4, 0.4],</span>
<span class="c1">##        [0.8, 0.8, 0.2, 0.1]])</span>
</pre></div>
</div>
<p>selects the rows whose mean is greater than 0.35.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">:</span> <span class="p">]</span>
<span class="c1">## array([[0. , 0.2, 0.4, 0.7],</span>
<span class="c1">##        [0.2, 0.6, 0.4, 0.4],</span>
<span class="c1">##        [0.8, 0.8, 0.2, 0.1]])</span>
</pre></div>
</div>
<p>orders the matrix with respect to the values in the first
row (all rows permuted in the same way, together).</p>
<div class="proof proof-type-exercise" id="id12">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.6</span>
        
    </div><div class="proof-content">
<p>In the
<a class="reference external" href="https://raw.githubusercontent.com/gagolews/teaching_data/master/marek/nhanes_adult_female_bmx_2020.csv"><code class="docutils literal notranslate"><span class="pre">nhanes_adult_female_bmx_2020</span></code></a> dataset,
select all the participants whose heights is within their
mean ± 2 standard deviations.</p>
</div></div></div>
<div class="section" id="two-vectors-as-indexers">
<h3><span class="section-number">8.2.4. </span>Two Vectors as Indexers (*)<a class="headerlink" href="#two-vectors-as-indexers" title="Permalink to this headline"></a></h3>
<p>With two vectors (logical or integer) things are a tad more
horrible, as in this case not only some
form <em>shape broadcasting</em> comes into play
but also all the headache-inducing exceptions
listed in the perhaps not the most clearly written
<a class="reference external" href="https://numpy.org/doc/stable/user/basics.indexing.html">Advanced Indexing</a>
section of the <strong class="program">numpy</strong> manual.
Cheer up, however, things in <strong class="program">pandas</strong> are much worse
(see <a class="reference internal" href="410-data-frame.html#sec-df-indexing"><span class="std std-numref">Section 10.5</span></a>).</p>
<p>For the sake of our maintaining sanity, in practice it is best
to stick only to the scenarios below and be extra careful
when using two vector indexers.</p>
<p>For two flat integer indexers, we pick elementwisely:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="p">]</span>
<span class="c1">## array([0.6, 0.2, 0.2, 0.2, 0.6])</span>
</pre></div>
</div>
<p>yields <code class="docutils literal notranslate"><span class="pre">A[0,</span> <span class="pre">1]</span></code>, <code class="docutils literal notranslate"><span class="pre">A[-1,</span> <span class="pre">2]</span></code>, <code class="docutils literal notranslate"><span class="pre">A[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">A[2,</span> <span class="pre">2]</span></code>, and <code class="docutils literal notranslate"><span class="pre">A[0,</span> <span class="pre">1]</span></code>.</p>
<p>In order to select a submatrix using integer indexes,
it is best to make sure that the first indexer is a column vector,
and the second is a row vector (or some object like the
two said ones, e.g., compatible lists of lists).
Further, if indexing involves logical vectors,
it is best to convert them to integer ones first
(e.g., by calling <strong class="command">numpy.nonzero</strong>).</p>
<p>The above transformations can be done automatically
via the <strong class="command">numpy.ix_</strong> function, which is always the safest choice:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.35</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="p">]</span>
<span class="c1">## array([[0.2, 0.4, 0.4, 0.2],</span>
<span class="c1">##        [0.8, 0.2, 0.1, 0.8]])</span>
</pre></div>
</div>
<p>Alternatively, we can always apply indexing twice instead
(which we will anyway be forced to do in <strong class="program">pandas</strong>
whenever selecting rows by number and columns by names is required).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.45</span><span class="p">,</span> <span class="p">:][:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="c1">## array([[0.8, 0.2, 0.1, 0.8]])</span>
</pre></div>
</div>
</div>
<div class="section" id="views-on-existing-arrays">
<h3><span class="section-number">8.2.5. </span>Views on Existing Arrays (*)<a class="headerlink" href="#views-on-existing-arrays" title="Permalink to this headline"></a></h3>
<p>Only indexing involving two slices or a slice and a scalar returns a
<a class="reference external" href="https://numpy.org/devdocs/user/basics.copies.html">view</a>
on an existing array.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span>
<span class="n">B</span>
<span class="c1">## array([[0.2, 0.4],</span>
<span class="c1">##        [0. , 0.4],</span>
<span class="c1">##        [0.8, 0.2]])</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> share memory. Therefore, by modifying <code class="docutils literal notranslate"><span class="pre">B</span></code>
in-place, e.g.,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<p>the changes will be visible in <code class="docutils literal notranslate"><span class="pre">A</span></code> as well:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>
<span class="c1">## array([[-0.2,  0.6, -0.4,  0.4],</span>
<span class="c1">##        [-0. ,  0.2, -0.4,  0.7],</span>
<span class="c1">##        [-0.8,  0.8, -0.2,  0.1]])</span>
</pre></div>
</div>
<p>This is time and memory efficient, but
might lead to some unexpected results if we are not
focused enough. We have been warned.</p>
</div>
<div class="section" id="adding-and-modifying-rows-and-columns">
<h3><span class="section-number">8.2.6. </span>Adding and Modifying Rows and Columns<a class="headerlink" href="#adding-and-modifying-rows-and-columns" title="Permalink to this headline"></a></h3>
<p>With slice/scalar-based indexers,
rows/columns/individual elements can be replaced by
new content in a natural way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>With <strong class="command">numpy</strong> arrays, however, brand new rows or columns cannot
be added using the index operator. Instead, the whole array needs to
be created from scratch using, for example, one
of the functions discussed in <a class="reference internal" href="310-matrix.html#sec-stacking-array"><span class="std std-numref">Section 7.1.4</span></a>.</p>
<p>Here is an example where we add a new column to the <code class="docutils literal notranslate"><span class="pre">A</span></code> matrix
being a function of the first column:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])))</span>
<span class="n">A</span>
<span class="c1">## array([[ 0.04,  0.6 , -0.4 ,  0.4 ,  0.2 ],</span>
<span class="c1">##        [ 0.  ,  0.2 , -0.4 ,  0.7 ,  0.  ],</span>
<span class="c1">##        [ 0.64,  0.8 , -0.2 ,  0.1 ,  0.8 ]])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="matrix-multiplication-dot-products-and-the-euclidean-norm">
<span id="sec-matrix-multiply"></span><h2><span class="section-number">8.3. </span>Matrix Multiplication, Dot Products, and the Euclidean Norm<a class="headerlink" href="#matrix-multiplication-dot-products-and-the-euclidean-norm" title="Permalink to this headline"></a></h2>
<p>Matrix algebra is at the core of most methods used in data analysis
and matrix multiply is one of the most fundamental operations therein
(e.g., <span id="id1">[<a class="reference internal" href="999-bibliography.html#id71">DFO20</a>, <a class="reference internal" href="999-bibliography.html#id126">Gen17</a>]</span>).</p>
<p>Given <span class="math notranslate nohighlight">\(\mathbf{A}\in\mathbb{R}^{n\times p}\)</span>
and <span class="math notranslate nohighlight">\(\mathbf{B}\in\mathbb{R}^{p\times m}\)</span>, their <em>multiply</em> is a matrix
<span class="math notranslate nohighlight">\(\mathbf{C}=\mathbf{A}\mathbf{B}\in\mathbb{R}^{n\times m}\)</span>
such that <span class="math notranslate nohighlight">\(c_{i,j}\)</span> is the sum of the <span class="math notranslate nohighlight">\(i\)</span>-th row in <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>
and the <span class="math notranslate nohighlight">\(j\)</span>-th column in <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> multiplied elementwisely:</p>
<div class="math notranslate nohighlight">
\[
c_{i,j} = a_{i, 1} b_{1, j} + a_{i, 2} b_{2, j} + \dots + a_{i, p} b_{p, j}
= \sum_{k=1}^p a_{i,k} b_{k, j}
\]</div>
<p>for <span class="math notranslate nohighlight">\(i=1,\dots,n\)</span> and <span class="math notranslate nohighlight">\(j=1,\dots,m\)</span>.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">])</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">B</span>  <span class="c1"># or: A.dot(B)</span>
<span class="n">C</span>
<span class="c1">## array([[ 3, -1,  3,  1],</span>
<span class="c1">##        [ 4,  6,  5,  7],</span>
<span class="c1">##        [ 3,  5,  2,  6],</span>
<span class="c1">##        [ 7,  7, 11,  9],</span>
<span class="c1">##        [ 2,  0,  3,  1]])</span>
</pre></div>
</div>
<p>Mathematically, we can write the above as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left[
\begin{array}{ccc}
1 &amp; 0 &amp; 1 \\
2 &amp; 2 &amp; 1 \\
3 &amp; 2 &amp; 0 \\
\color{red}{1} &amp; \color{red}{2} &amp; \color{red}{3} \\
0 &amp; 0 &amp; 1 \\
\end{array}
\right]
\,
\left[
\begin{array}{cccc}
1 &amp; -1 &amp; \color{red}{0} &amp; 0 \\
0 &amp;  4 &amp; \color{red}{1} &amp; 3 \\
2 &amp;  0 &amp; \color{red}{3} &amp; 1 \\
\end{array}
\right]
=
\left[
\begin{array}{cccc}
3 &amp; -1 &amp;  3 &amp;  1 \\
4 &amp;  6 &amp;  5 &amp;  7 \\
3 &amp;  5 &amp;  2 &amp;  6 \\
7 &amp;  7 &amp; \color{red}{11} &amp;  9 \\
2 &amp;  0 &amp;  3 &amp;  1 \\
\end{array}
\right].
\end{split}\]</div>
<p>For example, the element in the 4th row and 3rd column,
<span class="math notranslate nohighlight">\(c_{4,3}\)</span> takes the 4th row in the left matrix
<span class="math notranslate nohighlight">\(\mathbf{a}_{4,\cdot}=[1\, 2\, 3]\)</span>
and the 3rd column in the right matrix <span class="math notranslate nohighlight">\(\mathbf{b}_{\cdot,3}=[0\, 1\, 3]^T\)</span>
(they are marked in red), multiplies the corresponding elements and
computes their sum, i.e., <span class="math notranslate nohighlight">\(c_{4,3}=1\cdot 0 + 2\cdot 1 + 3\cdot 3 = 11\)</span>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Matrix multiplication can only be performed on two
matrices of <em>compatible sizes</em> – the number of columns in the left matrix
must match the number of rows in the right operand.</p>
</div>
<p>Another example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">])</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">])</span>
<span class="n">A</span> <span class="o">@</span> <span class="n">I</span>  <span class="c1"># or A.dot(I)</span>
<span class="c1">## array([[1, 2],</span>
<span class="c1">##        [3, 4]])</span>
</pre></div>
</div>
<p>We matrix-multiplied <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> by the identity matrix <span class="math notranslate nohighlight">\(\mathbf{I}\)</span>,
which is a neutral element of the said operation,
and hence the result is identical to <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>In most textbooks, just like in this one,
<span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{B}\)</span> almost always denotes the matrix multiplication
which is a very different operation to the elementwise multiplication.</p>
</div>
<p>Compare the above to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">*</span> <span class="n">I</span>  <span class="c1"># elementwise multiplication</span>
<span class="c1">## array([[1, 0],</span>
<span class="c1">##        [0, 4]])</span>
</pre></div>
</div>
<div class="proof proof-type-exercise" id="id13">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.7</span>
        
    </div><div class="proof-content">
<p>Show that <span class="math notranslate nohighlight">\(\mathbf{A}^T \mathbf{A}\)</span>
gives the matrix that consists of the dot products of all the pairs
of columns in <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>
and <span class="math notranslate nohighlight">\(\mathbf{A} \mathbf{A}^T\)</span> stores the dot products of all the
pairs of rows.</p>
</div></div><div class="proof proof-type-exercise" id="id14">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.8</span>
        
    </div><div class="proof-content">
<p>(*) Show that
<span class="math notranslate nohighlight">\((\mathbf{A}\mathbf{B})^T=\mathbf{B}^T \mathbf{A}^T\)</span>.
Also note that, typically, matrix multiplication
is not commutative.</p>
</div></div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Matrix multiplication gives a convenient means for denoting
sums of products of corresponding elements in many pairs of vectors,
which we refer to as dot products.</p>
<p>Given two vectors <span class="math notranslate nohighlight">\(\boldsymbol{x}, \boldsymbol{y} \in \mathbb{R}^p\)</span>,
their <em>dot (or scalar) product</em> is given by</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{x} \cdot \boldsymbol{y} = \sum_{i=1}^p x_i y_i.
\]</div>
<p>Thus, in matrix multiplication terms,
if <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is a row vector
and <span class="math notranslate nohighlight">\(\mathbf{y}^T\)</span> is a column vector,
then the above can be written as <span class="math notranslate nohighlight">\(\mathbf{x} \mathbf{y}^T\)</span>.
Note that the result is a single number.</p>
</div>
<p>In particular, a dot product of a vector and itself,</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{x} \cdot \boldsymbol{x} = \sum_{i=1}^p x_i^2,
\]</div>
<p>is the square of the Euclidean norm of <span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span>,
which – as we have said in <a class="reference internal" href="220-transform-vector.html#sec-normalisation"><span class="std std-numref">Section 5.3.2.3</span></a> –
we use to measure the <em>length</em> of a vector,</p>
<div class="math notranslate nohighlight">
\[
\|\boldsymbol{x}\| = \sqrt{\sum_{i=1}^p x_i^2}
=\sqrt{\boldsymbol{x} \cdot \boldsymbol{x}}
=\sqrt{\mathbf{x} \mathbf{x}^T}.
\]</div>
<p>The Euclidean norm fulfils (amongst others) the condition
that <span class="math notranslate nohighlight">\(\|\boldsymbol{x}\|=0\)</span> if and only if
<span class="math notranslate nohighlight">\(\boldsymbol{x}=\boldsymbol{0}=(0,0,\dots,0)\)</span>.
The same of course holds for its square.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To avoid notation clutter, we will often be implicitly  promoting
vectors like <span class="math notranslate nohighlight">\(\boldsymbol{x}=(x_1,\dots,x_p)\)</span>
to row vectors <span class="math notranslate nohighlight">\(\mathbf{x}=[x_1\,\cdots\,x_p]\)</span>,
because this is the behaviour that <strong class="program">numpy</strong> uses<a class="footnote-reference brackets" href="#footcolumnwisevecs" id="id2">1</a>.</p>
</div>
<p>In <a class="reference internal" href="330-relationship.html#sec-geometric-transform"><span class="std std-numref">Section 9.3.2</span></a> we will
see that matrix multiplication can be used as a way to express
certain geometrical transformations of points in a dataset,
e.g., scaling and rotating.</p>
<p>Also, in <a class="reference internal" href="330-relationship.html#sec-matrix-inverse"><span class="std std-numref">Section 9.3.3</span></a> we briefly discuss
the concept of the inverse of a matrix
and in <a class="reference internal" href="330-relationship.html#sec-svd"><span class="std std-numref">Section 9.3.4</span></a> its singular value decomposition.</p>
</div>
<div class="section" id="pairwise-distances-and-related-methods">
<span id="sec-distances"></span><h2><span class="section-number">8.4. </span>Pairwise Distances and Related Methods<a class="headerlink" href="#pairwise-distances-and-related-methods" title="Permalink to this headline"></a></h2>
<p>Many data analysis methods rely on the notion of
<em>distances</em> between points,
which quantify the extent to which two points
(e.g., two rows in a matrix) are different from each other.
Here we will be dealing with the most natural distance
called the Euclidean metric.
We know it from school, where we measured how two points
are far away from each other with a ruler.</p>
<div class="section" id="the-euclidean-metric">
<h3><span class="section-number">8.4.1. </span>The Euclidean Metric<a class="headerlink" href="#the-euclidean-metric" title="Permalink to this headline"></a></h3>
<p>Given two vectors of length <span class="math notranslate nohighlight">\(m\)</span>,
<span class="math notranslate nohighlight">\(\boldsymbol{u}=(u_1,\dots,u_m)\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{v}=(v_1,\dots,v_m)\)</span>, the <em>Euclidean metric</em> is defined in terms of the corresponding Euclidean
norm</p>
<div class="math notranslate nohighlight">
\[
\|\boldsymbol{u} - \boldsymbol{v}\| = \sqrt{
(u_1-v_1)^2 + (u_2-v_2)^2 + \dots + (u_m-v_m)^2
}
=
\sqrt{
\sum_{i=1}^m (u_i-v_i)^2
},
\]</div>
<p>that is, it is the square root of the sum of squared differences
between the corresponding vector components.</p>
<div class="proof proof-type-exercise" id="id15">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.9</span>
        
    </div><div class="proof-content">
<p>Consider the following matrix <span class="math notranslate nohighlight">\(\mathbf{X}\in\mathbb{R}^{4\times 2}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{X} = \left[\begin{array}{cc}
0 &amp; 0 \\
1 &amp; 0 \\
-\frac{3}{2} &amp; 1 \\
1 &amp; 1 \\
\end{array}\right].
\end{split}\]</div>
<p>Calculate (by hand)
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{1,\cdot}, \mathbf{x}_{2,\cdot}\|\)</span>,
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{1,\cdot}, \mathbf{x}_{3,\cdot}\|\)</span>,
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{1,\cdot}, \mathbf{x}_{4,\cdot}\|\)</span>,
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{2,\cdot}, \mathbf{x}_{4,\cdot}\|\)</span>,
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{2,\cdot}, \mathbf{x}_{3,\cdot}\|\)</span>,
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{1,\cdot}, \mathbf{x}_{1,\cdot}\|\)</span>, and
<span class="math notranslate nohighlight">\(\|\mathbf{x}_{2,\cdot}, \mathbf{x}_{1,\cdot}\|\)</span>.</p>
</div></div><div class="admonition important">
<p class="admonition-title">Important</p>
<p>Note that for unidimensional data (<span class="math notranslate nohighlight">\(m=1\)</span>)
we have <span class="math notranslate nohighlight">\(\|u-v\|=|u-v|\)</span>.</p>
</div>
<p>The distances between all the pairs of rows
in two matrices <span class="math notranslate nohighlight">\(\mathbf{X}\in\mathbb{R}^{n\times m}\)</span>
and <span class="math notranslate nohighlight">\(\mathbf{Y}\in\mathbb{R}^{k\times m}\)</span> can be computed by calling
<strong class="command">scipy.spatial.distance.cdist</strong>.
We need to be careful, though, because they result in
a distance matrix of size <span class="math notranslate nohighlight">\(n\times k\)</span>, which can become quite large
(e.g., for <span class="math notranslate nohighlight">\(n=k=100000\)</span> we would need ca. 80 GB of RAM to store it).</p>
<p>Here are the distances between all the pairs of points in the same
dataset.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span>    <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span><span class="p">]</span>
<span class="p">])</span>
<span class="kn">import</span> <span class="nn">scipy.spatial.distance</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
<span class="n">D</span>
<span class="c1">## array([[0.        , 1.        , 1.80277564, 1.41421356],</span>
<span class="c1">##        [1.        , 0.        , 2.6925824 , 1.        ],</span>
<span class="c1">##        [1.80277564, 2.6925824 , 0.        , 2.5       ],</span>
<span class="c1">##        [1.41421356, 1.        , 2.5       , 0.        ]])</span>
</pre></div>
</div>
<p>Hence, <span class="math notranslate nohighlight">\(d_{i,j}=\|\mathbf{x}_{i,\cdot}-\mathbf{x}_{j,\cdot}\|\)</span>.
That we have zeros on the diagonal
is due to the fact that <span class="math notranslate nohighlight">\(\|\boldsymbol{u} - \boldsymbol{v}\|= 0\)</span>
if and only if <span class="math notranslate nohighlight">\(\boldsymbol{u} = \boldsymbol{v}\)</span>.
Furthermore, <span class="math notranslate nohighlight">\(\|\boldsymbol{u} - \boldsymbol{v}\|=\|\boldsymbol{v} - \boldsymbol{u}\|\)</span>, which implies the symmetry of <span class="math notranslate nohighlight">\(\mathbf{D}\)</span>.</p>
<p><a class="reference internal" href="#fig-euclid-dist-ex"><span class="std std-numref">Figure 8.2</span></a>
illustrates all the non-trivial pairwise distances.
Note that our perception of distance is disturbed because
of the aspect ratio (the ratio between the range of the x-axis
to the range of the y-axis) is not 1:1.
This is why it is very important, when judging spatial relationships
between the points, to call <strong class="command">matplotlib.pytplot.axis(&quot;equal&quot;)</strong>
or set the axis limits manually (which is left as an exercise).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;ko&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-default" id="id16">
<span id="fig-euclid-dist-ex"></span><img alt="../_images/euclid-dist-ex-3.png" src="../_images/euclid-dist-ex-3.png" />
<p class="caption"><span class="caption-number">Figure 8.2 </span><span class="caption-text">Distances between four example points. Their perception is disturbed because the aspect ratio is not 1:1</span><a class="headerlink" href="#id16" title="Permalink to this image"></a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are many possible distances,
allowing to measure the similarity of points not only in <span class="math notranslate nohighlight">\(\mathbb{R}^m\)</span>,
but also character strings (e.g., the Levenshtein metric),
ratings (e.g., cosine dissimilarity), etc.;
there is even an encyclopedia of distances <span id="id3">[<a class="reference internal" href="999-bibliography.html#id104">DD14</a>]</span>.</p>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>There are many techniques in data science that rely on
computing pairwise distances, including, but not limited to:</p>
<ul class="simple">
<li><p>multidimensional data aggregation (see below),</p></li>
<li><p><em>k</em>-means clustering (<a class="reference internal" href="430-group-by.html#sec-kmeans"><span class="std std-numref">Section 12.4</span></a>),</p></li>
<li><p><em>k</em>-nearest neighbour regression (<a class="reference internal" href="330-relationship.html#sec-knn-regression"><span class="std std-numref">Section 9.2.1</span></a>)
and classification (<a class="reference internal" href="430-group-by.html#sec-knn-classification"><span class="std std-numref">Section 12.3.1</span></a>),</p></li>
<li><p>density estimation (which we can use outlier detection,
see <a class="reference internal" href="520-missingness.html#sec-outliers"><span class="std std-numref">Section 15.4</span></a>),</p></li>
<li><p>missing value imputation (<a class="reference internal" href="520-missingness.html#sec-missing-data"><span class="std std-numref">Section 15.1</span></a>).</p></li>
</ul>
<p>In the sequel, whenever we apply them,
we will be assuming that data have been
appropriately preprocessed, in particular that columns
are on the same scale
(e.g., are standardised). Otherwise, computing their sums
of squared differences might not make sense at all.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Given two vectors of equal lengths
<span class="math notranslate nohighlight">\(\boldsymbol{x},\boldsymbol{y}\in\mathbb{R}^p\)</span>,
the dot product of their difference,</p>
<div class="math notranslate nohighlight">
\[
(\boldsymbol{x}-\boldsymbol{y})\cdot (\boldsymbol{x}-\boldsymbol{y})
= (\mathbf{x}-\mathbf{y}) (\mathbf{x}-\mathbf{y})^T
= \sum_{i=1}^{p} (x_i-y_i)^2
\]</div>
<p>is nothing else than the square of the Euclidean distance between them.</p>
</div>
</div>
<div class="section" id="centroids">
<span id="sec-centroid"></span><h3><span class="section-number">8.4.2. </span>Centroids<a class="headerlink" href="#centroids" title="Permalink to this headline"></a></h3>
<p>So far we have only been discussing ways to aggregate unidimensional data
(for instance, each matrix column separately).
It turns out that some summaries can be generalised
to the multidimensional case.</p>
<p>For instance, it can be shown that the arithmetic mean of
a vector <span class="math notranslate nohighlight">\((x_1,\dots,x_n)\)</span> is a point <span class="math notranslate nohighlight">\(c\)</span> that
minimises the sum of the <em>squared</em> 1-dimensional distances
between itself and all the <span class="math notranslate nohighlight">\(x_i\)</span>s, i.e.,
<span class="math notranslate nohighlight">\(\sum_{i=1}^n \|x_i-c\|^2=\sum_{i=1}^n (x_i-c)^2\)</span>.</p>
<p>Thus, we can define the <em>centroid</em> of a dataset
<span class="math notranslate nohighlight">\(\mathbf{X}\in\mathbb{R}^{n\times m}\)</span> as
the point <span class="math notranslate nohighlight">\(\boldsymbol{c}\in\mathbb{R}^m\)</span> to which the overall
<em>squared</em> distance is the smallest</p>
<div class="math notranslate nohighlight">
\[
\text{minimise}\ \sum_{i=1}^n \| \mathbf{x}_{i,\cdot}-\boldsymbol{c}\|^2
\qquad\text{w.r.t. }\boldsymbol{c}.
\]</div>
<p>It can be shown that the solution to the above is</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{c} =
\frac{1}{n}\left(
\mathbf{x}_{1, \cdot}+\mathbf{x}_{2, \cdot}+\dots+\mathbf{x}_{n, \cdot}
\right)
=
\frac{1}{n} \sum_{i=1}^n \mathbf{x}_{i, \cdot},
\]</div>
<p>which is the componentwise arithmetic mean, i.e., its <span class="math notranslate nohighlight">\(j\)</span>-th component is</p>
<div class="math notranslate nohighlight">
\[
c_j = \frac{1}{n} \sum_{i=1}^n x_{i, j}.
\]</div>
<p>For instance, the centroid of the above dataset is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">c</span>
<span class="c1">## array([0.125, 0.5  ])</span>
</pre></div>
</div>
<p>Centroids are, amongst others, a basis for the <em>k</em>-means
clustering method that we discuss in <a class="reference internal" href="430-group-by.html#sec-kmeans"><span class="std std-numref">Section 12.4</span></a>.</p>
</div>
<div class="section" id="multidimensional-dispersion-and-other-aggregates">
<span id="sec-aggmultidim"></span><h3><span class="section-number">8.4.3. </span>Multidimensional Dispersion and Other Aggregates<a class="headerlink" href="#multidimensional-dispersion-and-other-aggregates" title="Permalink to this headline"></a></h3>
<p>Furthermore, as a measure of multidimensional dispersion,
we can consider the natural generalisation of the standard deviation,</p>
<div class="math notranslate nohighlight">
\[
s=
\sqrt{
\frac{1}{n}
\sum_{i=1}^n
\| \mathbf{x}_{i,\cdot}-\boldsymbol{c}\|^2
},
\]</div>
<p>being the square root of the average squared distance
to the centroid. Note that it is a single number.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="c1">## 1.1388041973930374</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>(**) Generalising other aggregation
functions is not a trivial task, because, amongst others,
there is no natural linear ordering relation in the
multidimensional space (see, e.g., <span id="id4">[<a class="reference internal" href="999-bibliography.html#id22">PFBG19</a>]</span>).
For instance, any point on the convex hull of a dataset
could serve as the analogue of the minimal and maximal observation.
Furthermore, the componentwise median does not behave nicely
(it may, for example, fall outside the convex hull). Thus,
instead, we usually consider a different generalisation of the median
being the point that minimises the sum of distances (not squared),
<span class="math notranslate nohighlight">\(\sum_{i=1}^n \| \mathbf{x}_{i,\cdot}-\boldsymbol{c}\|\)</span>;
sadly, it does not have an analytic solution
(can be determined algorithmically).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>(**) A bag plot <span id="id5">[<a class="reference internal" href="999-bibliography.html#id129">RRT99</a>]</span>
is one of the possible multidimensional generalisations
of the box-and-whisker plot. Unfortunately, its use is quite limited
due its low popularity amongst practitioners.</p>
</div>
</div>
<div class="section" id="fixed-radius-and-k-nearest-neighbour-search">
<span id="sec-knn-vs-radius"></span><h3><span class="section-number">8.4.4. </span>Fixed-Radius and <em>K</em>-Nearest Neighbour Search<a class="headerlink" href="#fixed-radius-and-k-nearest-neighbour-search" title="Permalink to this headline"></a></h3>
<p>A number of data analysis techniques relies upon
aggregating information about what is happening in the
<em>local neighbourhoods</em> of the points.
Let <span class="math notranslate nohighlight">\(\mathbf{X}\in\mathbb{R}^{n\times m}\)</span> be a dataset
and <span class="math notranslate nohighlight">\(\boldsymbol{y}\in\mathbb{R}^m\)</span> be some point, not necessarily
from <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>. We basically have two options:</p>
<ul>
<li><p><em>fixed-radius search</em>: for some radius <span class="math notranslate nohighlight">\(r&gt;0\)</span>,
we seek the indices of all the points in <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> whose distance to
<span class="math notranslate nohighlight">\(\boldsymbol{y}\)</span> is not greater than <span class="math notranslate nohighlight">\(r\)</span></p>
<div class="math notranslate nohighlight">
\[
    B_r(\boldsymbol{y}) = \left\{
    i: \|\mathbf{x}_{i,\cdot} - \boldsymbol{y}\| \le r
    \right\};
    \]</div>
</li>
<li><p><em>few nearest-neighbour search</em>: for some (usually small) integer <span class="math notranslate nohighlight">\(k\ge 1\)</span>,
we seek the indices of the <span class="math notranslate nohighlight">\(k\)</span> points in <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>
which are the closest to <span class="math notranslate nohighlight">\(\boldsymbol{y}\)</span></p>
<div class="math notranslate nohighlight">
\[
    N_k(\boldsymbol{y}) = \{
    i_1, i_2, \dots, i_k
    \}
    \]</div>
<p>such that for all <span class="math notranslate nohighlight">\(j\not\in\{i_1,\dots,i_k\}\)</span></p>
<div class="math notranslate nohighlight">
\[
    \| \mathbf{x}_{i_1,\cdot} -\boldsymbol{y} \|
    \le
    \| \mathbf{x}_{i_2,\cdot} -\boldsymbol{y} \|
    \le\dots\le
    \| \mathbf{x}_{i_k,\cdot} -\boldsymbol{y} \|
    \le
    \| \mathbf{x}_{j,\cdot} -\boldsymbol{y} \|.
    \]</div>
</li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>In <span class="math notranslate nohighlight">\(\mathbb{R}^1\)</span>,
<span class="math notranslate nohighlight">\(B_r(\boldsymbol{y})\)</span> is an interval of length <span class="math notranslate nohighlight">\(2r\)</span>
centred at <span class="math notranslate nohighlight">\(\boldsymbol{y}\)</span>,
i.e., <span class="math notranslate nohighlight">\([y_1-r, y_1+r]\)</span>.
In <span class="math notranslate nohighlight">\(\mathbb{R}^2\)</span>,
<span class="math notranslate nohighlight">\(B_r(\boldsymbol{y})\)</span> is a circle of radius <span class="math notranslate nohighlight">\(r\)</span>
centred at <span class="math notranslate nohighlight">\((y_1, y_2)\)</span>.
More generally, we call <span class="math notranslate nohighlight">\(B_r(\boldsymbol{y})\)</span>
an <span class="math notranslate nohighlight">\(m\)</span>-dimensional (Euclidean) ball or a solid hypersphere.</p>
</div>
<p>Here is an example dataset, consisting of some randomly generated points
(see figure below).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">777</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Local neighbourhoods can of course be determined
by computing the distances between each point in <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>
and <span class="math notranslate nohighlight">\(\boldsymbol{y}\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.spatial.distance</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>For instance, here are the indices
of the points in <span class="math notranslate nohighlight">\(B_{0.75}(\boldsymbol{y})\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="mf">0.75</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">D</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span>
<span class="n">B</span>
<span class="c1">## array([ 1, 11, 14, 16, 24])</span>
</pre></div>
</div>
<p>And here are the 11 nearest neighbours:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))[:</span><span class="n">k</span><span class="p">]</span>
<span class="n">N</span>
<span class="c1">## array([14, 24, 16, 11,  1, 22,  7, 19,  0,  9, 15])</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#fig-euclid-search-ex"><span class="std std-numref">Figure 8.3</span></a> for an illustration
(note that the aspect ratio is set to 1:1 as otherwise the circle
would look like an ellipse).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">]],</span> <span class="s2">&quot;r:&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;bo&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;rX&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;$</span><span class="se">\\</span><span class="s2">mathbf</span><span class="si">{y}</span><span class="s2">$&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-default" id="id17">
<span id="fig-euclid-search-ex"></span><img alt="../_images/euclid-search-ex-5.png" src="../_images/euclid-search-ex-5.png" />
<p class="caption"><span class="caption-number">Figure 8.3 </span><span class="caption-text">Fixed-radius vs few-nearest neighbour search</span><a class="headerlink" href="#id17" title="Permalink to this image"></a></p>
</div>
</div>
<div class="section" id="spatial-search-with-k-d-trees">
<h3><span class="section-number">8.4.5. </span>Spatial Search with <em>K</em>-d Trees<a class="headerlink" href="#spatial-search-with-k-d-trees" title="Permalink to this headline"></a></h3>
<p>For efficiency reasons,
it is better to rely on dedicated spatial search data structures,
especially if we have a large number of neighbourhood-related queries.
<strong class="program">scipy</strong> implements such a search algorithm based on the
so-called <em>K</em>-dimensional trees (<em>K</em>-d trees;
in our context, we should prefer referring to them as <em>m</em>-d trees,
but let us stick with the traditional name).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>(*)
In <em>K</em>-d trees, the data space is partitioned into hyperrectangles
along the axes of the Cartesian coordinate system
(standard basis). Thanks to such a representation,
all subareas which are too far from the point of interest
can be pruned to speed up the search.</p>
</div>
<p>Let us create the data structure for searching within the
above <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> matrix.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.spatial</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">KDTree</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>Assume we would like to make queries with regards to the 3 following
pivot points.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="p">])</span>
</pre></div>
</div>
<p>Here are the results for the fixed radius searches:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>  <span class="c1"># r was defined above</span>
<span class="c1">## array([list([1, 11, 14, 16, 24]), list([20]), list([])], dtype=object)</span>
</pre></div>
</div>
<p>We see that the search was nicely vectorised; we have made
a query about many points all at the same time.
In result, we received a list-like object storing
three lists representing the resulting indices, each for a different
input point.
Note that in the case of the 3rd point,
there are no elements in <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>
within the range (ball) of interest, hence the empty index list.</p>
<p>And here are the nearest neighbours:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>  <span class="c1"># k was defined above</span>
<span class="c1">## (array([[0.31457701, 0.44600012, 0.54848109, 0.64875661, 0.71635172,</span>
<span class="c1">##         0.80435675, 0.84401121, 0.89488218, 0.94671021, 0.95240875,</span>
<span class="c1">##         0.96257142],</span>
<span class="c1">##        [0.20356263, 1.45896222, 1.61587605, 1.64870864, 2.04640408,</span>
<span class="c1">##         2.2021443 , 2.20687238, 2.29585085, 2.90551519, 2.9678564 ,</span>
<span class="c1">##         3.02393202],</span>
<span class="c1">##        [1.2494805 , 1.35482619, 1.93984334, 1.95938464, 2.08926502,</span>
<span class="c1">##         2.17968448, 2.30592773, 2.43335828, 2.50319585, 2.51159254,</span>
<span class="c1">##         2.7345559 ]]), array([[14, 24, 16, 11,  1, 22,  7, 19,  0,  9, 15],</span>
<span class="c1">##        [20,  5, 13,  2,  9, 15, 21, 18, 11, 16, 19],</span>
<span class="c1">##        [17,  3, 21, 12, 22, 11, 15,  1, 13,  9,  0]]))</span>
</pre></div>
</div>
<p>We obtained both the distances to the nearest neighbours
as well as the indices, in the form of two separate matrices
with 3 rows (corresponding to the number of pivot points) and 11
columns (the number of neighbours sought for).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>(**)
We expect the <em>K</em>-d trees to be much faster than the brute-force approach
(where we compute all pairwise distances) in low-dimensional spaces.
However, due to the phenomenon called the <em>curse of dimensionality</em>,
sometimes already for <span class="math notranslate nohighlight">\(m\ge 5\)</span> the speed gains might be very small.</p>
</div>
</div>
</div>
<div class="section" id="exercises">
<h2><span class="section-number">8.5. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline"></a></h2>
<div class="proof proof-type-exercise" id="id18">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.10</span>
        
    </div><div class="proof-content">
<p>Does <strong class="command">numpy.mean</strong><strong class="command">(A, axis=0)</strong>
compute rowwise or columnwise means?</p>
</div></div><div class="proof proof-type-exercise" id="id19">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.11</span>
        
    </div><div class="proof-content">
<p>How does shape broadcasting work? List the most common pairs of shape cases
when performing arithmetic operations.</p>
</div></div><div class="proof proof-type-exercise" id="id20">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.12</span>
        
    </div><div class="proof-content">
<p>What are the possible matrix indexing schemes
and how do they behave?</p>
</div></div><div class="proof proof-type-exercise" id="id21">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.13</span>
        
    </div><div class="proof-content">
<p>Which kinds of matrix indexers return a view on an existing array?</p>
</div></div><div class="proof proof-type-exercise" id="id22">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.14</span>
        
    </div><div class="proof-content">
<p>(*) How to select a submatrix comprised of
the first and the last row and the first and the last column?</p>
</div></div><div class="proof proof-type-exercise" id="id23">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.15</span>
        
    </div><div class="proof-content">
<p>Why appropriate data preprocessing is required when computing
the Euclidean distance between points?</p>
</div></div><div class="proof proof-type-exercise" id="id24">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.16</span>
        
    </div><div class="proof-content">
<p>What is the relationship between the dot product,
the Euclidean norm,
and the Euclidean distance?</p>
</div></div><div class="proof proof-type-exercise" id="id25">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.17</span>
        
    </div><div class="proof-content">
<p>What is a centroid? How is it defined by means of the Euclidean distance
between the points in a dataset?</p>
</div></div><div class="proof proof-type-exercise" id="id26">

    <div class="proof-title">
        <span class="proof-type">Exercise 8.18</span>
        
    </div><div class="proof-content">
<p>When <em>K</em>-d tress or other spatial search data structures might
be better than a brute-force search with
<strong class="command">scipy.spatial.distance.cdist</strong>?</p>
</div></div><hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="footcolumnwisevecs"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>However, some textbooks assume that all
vectors are column vectors; in such a case, they would define
the Euclidean norm as
<span class="math notranslate nohighlight">\(\|\boldsymbol{x}\|=\sqrt{\mathbf{x}^T \mathbf{x}}\)</span>.</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="330-relationship.html" class="btn btn-neutral float-right" title="9. Exploring Relationships Between Variables" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="310-matrix.html" class="btn btn-neutral float-left" title="7. Multidimensional Numeric Data at a Glance" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        Copyright &#169; 2022 by <a href="https://www.gagolewski.com">Marek Gagolewski</a>. Some rights reserved. Licensed under <a href='https://creativecommons.org/licenses/by-nc-nd/4.0/'>CC BY-NC-ND 4.0</a>.
      <span class="lastupdated">
        Last updated on 2022-06-21T12:19:42+1000.
      </span>
    Built with <a href="https://sphinx-doc.org/">Sphinx</a>
    and a customised <a href="https://github.com/rtfd/sphinx_rtd_theme">rtd</a> theme.
    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>