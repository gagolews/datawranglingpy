<!DOCTYPE html>


<html class="writer-html5" lang="en" >
<!-- Copyright (C) 2020-2021, Marek Gagolewski <https://www.gagolewski.com> -->

<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>10. Processing Time Series &mdash; Minimalist Data Wrangling with Python by Marek Gagolewski</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/proof.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  
    <link rel="canonical" href="https://datawranglingpy.gagolewski.com/chapter/270-time-uni.html" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/proof.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="11. Introduction to Matrices in numpy" href="310-matrix.html" />
    <link rel="prev" title="9. Handling Categorical Data" href="260-categorical-uni.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html"> Minimalist Data Wrangling with Python [DRAFTv0.1]
          

          
          </a>

          <div class="version">
          by <a style="color: inherit" href="https://www.gagolewski.com">Marek Gagolewski</a>
          </div>

<!--
          
            
            
              <div class="version">
                by Marek Gagolewski
              </div>
            
          
-->

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search phrase..." />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Start Here</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="000-preface.html">Preface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introducing Python</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="110-jupyter.html">1. Getting Started with Python and JupyterLab</a></li>
<li class="toctree-l1"><a class="reference internal" href="120-scalar.html">2. Scalar Types in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="130-sequential.html">3. Sequential and Other Types in Python</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Unidimensional Data</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="210-vector.html">4. Introduction to Vectors in <em>numpy</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="220-histogram.html">5. Inspecting the Distribution of Numeric Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="230-aggregate.html">6. Descriptive Statistics for Continuous Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="240-transform-uni.html">7. Transforming and Filtering Continuous Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="250-distribution-uni.html">8. Continuous Probability Distributions (**)</a></li>
<li class="toctree-l1"><a class="reference internal" href="260-categorical-uni.html">9. Handling Categorical Data</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">10. Processing Time Series</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#working-with-datetimes-and-timedeltas">10.1. Working with Datetimes and Timedeltas</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iterative-differences-and-cumulative-sums-revisited">10.2. Iterative Differences and Cumulative Sums Revisited</a></li>
<li class="toctree-l2"><a class="reference internal" href="#smoothing-with-moving-averages">10.3. Smoothing with Moving Averages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-note-on-nonuniform-sampling">10.4. A Note on Nonuniform Sampling (*)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dealing-with-nonequispaced-series">10.4.1. Dealing with Nonequispaced Series</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modelling-event-times-with-an-exponential-distribution">10.4.2. Modelling Event Times with an Exponential Distribution (**)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#further-reading">10.5. Further Reading</a></li>
<li class="toctree-l2"><a class="reference internal" href="#questions">10.6. Questions</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Multidimensional Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="310-matrix.html">11. Introduction to Matrices in <em>numpy</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="320-transform-multi.html">12. Transforming, Aggregating, and Filtering Multidimensional Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="330-categorical-multi.html">13. Multivariate Categorical and Relational Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="330-visualise-multi.html">14. Visualising Multidimensional Data and Measuring Correlation</a></li>
<li class="toctree-l1"><a class="reference internal" href="350-time-multi.html">15. Multidimensional Time Series</a></li>
<li class="toctree-l1"><a class="reference internal" href="360-image.html">16. Notes on Signal Processing (Audio, Image, Video)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Heterogeneous Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="410-dataframe.html">17. Introduction to Data Frames in <em>pandas</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="420-transform-hetero.html">18. Basic Operations on Data Frames</a></li>
<li class="toctree-l1"><a class="reference internal" href="430-reshape.html">19. Reshaping and Fusing Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="440-groupby.html">20. Observation Grouping</a></li>
<li class="toctree-l1"><a class="reference internal" href="450-missingness.html">21. Outliers, Missing, Censored, and Incorrect Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="460-sql.html">22. Database Access</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Text Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="510-text.html">23. Working with Text Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="520-regex.html">24. Regular Expressions (*)</a></li>
<li class="toctree-l1"><a class="reference internal" href="530-webscrape.html">25. Fetching and Cleaning Text Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="999-bibliography.html">Bibliography</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">External Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/datawranglingpy/blob/master/CODE_OF_CONDUCT.md">Report Bugs or Typos</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.gagolewski.com">Author</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Minimalist Data Wrangling with Python [DRAFTv0.1]</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">10. </span>Processing Time Series</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="310-matrix.html" class="btn btn-neutral float-right" title="11. Introduction to Matrices in numpy" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      
      
        <a href="260-categorical-uni.html" class="btn btn-neutral float-left" title="9. Handling Categorical Data" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="tex2jax_ignore mathjax_ignore section" id="processing-time-series">
<span id="chap-time-uni"></span><h1><span class="section-number">10. </span>Processing Time Series<a class="headerlink" href="#processing-time-series" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p><em>Minimalist Data Wrangling with Python</em> is a very-early-and-rough-draft
of the forthcoming (ETA 2023) textbook by
<a class="reference external" href="https://www.gagolewski.com">Marek Gagolewski</a>.
It is distributed in the hope that it will be useful.
If you detect any bugs or typos, please share them by
<a class="reference external" href="https://github.com/gagolews/datawranglingpy/blob/master/CODE_OF_CONDUCT.md">email</a>.
Although available online, this is a whole course, and should be read
from the beginning to the end. In particular, refer to the Preface for
general introductory remarks. Enjoy.</p>
</div></blockquote>
<p>So far we have been using <em>numpy</em> vectors mostly for storing:</p>
<ul class="simple">
<li><p><em>independent</em> measurements, e.g., where each element is
a height record of a different subject;
we often consider these a sample of a representative subset of a population
recorded at a particular point in time;</p></li>
<li><p>frequency distributions, i.e.,
count data and the corresponding categories or labels.</p></li>
</ul>
<p>In this part we’ll explore the most basic concepts related to the
wrangling of <em>time series</em> data – signals indexed by discrete time.
Usually a time series is a sequence of measurements
sampled at equally spaced moments, e.g.,
a patient’s heart rate probed every second,
daily opening stock market prices,
or average monthly temperatures recorded in some location.</p>
<p>Consider the midrange daily temperatures in degrees Celsius
at Spokane International Airport (Spokane, WA, US)
between 1889-08-01 (first observation) and 2021-12-31 (last observation).
Note that midrange, being the mean of the lowest and highest observed
temperature on a given day, is not a particularly good estimate
of the average daily reading, however, we must work with the data we have.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">temps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s2">&quot;https://raw.githubusercontent.com/gagolews/&quot;</span> <span class="o">+</span>
    <span class="s2">&quot;teaching_data/master/marek/spokane_temperature.txt&quot;</span><span class="p">)</span>
<span class="n">temps</span><span class="p">[</span><span class="o">-</span><span class="mi">31</span><span class="p">:]</span>  <span class="c1"># December 2021 data</span>
<span></span><span class="c1">## array([ 11.9,   5.8,   0.6,   0.8,  -1.9,  -4.4,  -1.9,   1.4,  -1.9,</span>
<span class="c1">##         -1.4,   3.9,   1.9,   1.9,  -0.8,  -2.5,  -3.6, -10. ,  -1.1,</span>
<span class="c1">##         -1.7,  -5.3,  -5.3,  -0.3,   1.9,  -0.6,  -1.4,  -5. ,  -9.4,</span>
<span class="c1">##        -12.8, -12.2, -11.4, -11.4])</span>
</pre></div>
</div>
<p>Here are some data aggregates – the popular quantiles:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">temps</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span></span><span class="c1">## array([-26.9,   2.2,   8.6,  16.4,  33.9])</span>
</pre></div>
</div>
<p>as well as the arithmetic mean and standard deviation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">temps</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">temps</span><span class="p">)</span>
<span></span><span class="c1">## (8.990273958441023, 9.16204388619955)</span>
</pre></div>
</div>
<p>and a graphical summary of the data distribution:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s2">&quot;seaborn&quot;</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">violinplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">temps</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;h&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-default" id="id1">
<span id="fig-270-time-uni-4"></span><img alt="../_images/270-time-uni-4-1.png" src="../_images/270-time-uni-4-1.png" />
<p class="caption"><span class="caption-number">Figure 10.1 </span><span class="caption-text">plot of chunk 270-time-uni-4</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>Contrary to the <em>independent</em> measurements case,
we do not have to treat vectors representing time series simply
as mixed bags of unrelated items (note that when computing data aggregates
or plotting histograms, the order of elements does not matter).</p>
<p>Instead, in time series, for any given
item <span class="math notranslate nohighlight">\(x_i\)</span>, its neighbouring elements <span class="math notranslate nohighlight">\(x_{i-1}\)</span> and <span class="math notranslate nohighlight">\(x_{i+1}\)</span>
denote the recordings occurring directly before and after it.
We can use this <em>temporal ordering</em> to model how consecutive
measurements <em>depend</em> on each other, describe how they
change over time, forecast future values, detect long-time trends, and so forth.</p>
<p>Here are the data for 2021, plotted as a function of time:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">temps</span><span class="p">[</span><span class="o">-</span><span class="mi">365</span><span class="p">:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">181</span><span class="p">,</span> <span class="mi">364</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;2021-01-01&quot;</span><span class="p">,</span> <span class="s2">&quot;2021-07-01&quot;</span><span class="p">,</span> <span class="s2">&quot;2021-12-31&quot;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span></span><span class="c1">## ([&lt;matplotlib.axis.XTick object at 0x7efec4896a30&gt;, &lt;matplotlib.axis.XTick object at 0x7efec4896e80&gt;, &lt;matplotlib.axis.XTick object at 0x7efec4896c40&gt;], [Text(0, 0, &#39;2021-01-01&#39;), Text(181, 0, &#39;2021-07-01&#39;), Text(364, 0, &#39;2021-12-31&#39;)])</span>
</pre></div>
</div>
<div class="figure align-default" id="id2">
<span id="fig-270-time-uni-5"></span><img alt="../_images/270-time-uni-5-3.png" src="../_images/270-time-uni-5-3.png" />
<p class="caption"><span class="caption-number">Figure 10.2 </span><span class="caption-text">plot of chunk 270-time-uni-5</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>We call this a <em>line chart</em> – data points are connected by straight line
segments.
There are some visible trends, such as that, well, obviously,
winter is colder than summer, duh.</p>
<div class="section" id="working-with-datetimes-and-timedeltas">
<h2><span class="section-number">10.1. </span>Working with Datetimes and Timedeltas<a class="headerlink" href="#working-with-datetimes-and-timedeltas" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.datetime.html"><code class="docutils literal notranslate"><span class="pre">numpy.datetime64</span></code></a> is a type to represent datetimes.</p>
<p>Usually, we’ll be creating datetimes from strings, for instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;1889-08-01&quot;</span><span class="p">,</span> <span class="s2">&quot;1970-01-01&quot;</span><span class="p">,</span> <span class="s2">&quot;2021-12-31&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;datetime64&quot;</span><span class="p">)</span>
<span class="n">d</span>
<span></span><span class="c1">## array([&#39;1889-08-01&#39;, &#39;1970-01-01&#39;, &#39;2021-12-31&#39;], dtype=&#39;datetime64[D]&#39;)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;1970-01-01T02:01:05&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;datetime64&quot;</span><span class="p">)</span>
<span class="n">dt</span>
<span></span><span class="c1">## array([&#39;1970-01-01T02:01:05&#39;], dtype=&#39;datetime64[s]&#39;)</span>
</pre></div>
</div>
<blockquote>
<div><p><strong>Note.</strong> In a farther part, we’ll be dealing
with datetimes in nonstandard formats, e.g., <code class="docutils literal notranslate"><span class="pre">&quot;08/31/1996&quot;</span></code>.</p>
</div></blockquote>
<p>Internally, the above are represented as
the number of days or seconds since the so-called Unix Epoch,
1970-01-01T00:00:00 in the UTC time zone:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span></span><span class="c1">## array([-29372.,      0.,  18992.])</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span></span><span class="c1">## array([7265.])</span>
</pre></div>
</div>
<p>Computing datetime differences is possible thanks
to the <code class="docutils literal notranslate"><span class="pre">numpy.timedelta64</span></code> objects:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">d</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">)</span>  <span class="c1"># minus 1 Day</span>
<span></span><span class="c1">## array([&#39;1889-07-31&#39;, &#39;1969-12-31&#39;, &#39;2021-12-30&#39;], dtype=&#39;datetime64[D]&#39;)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dt</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">)</span>  <span class="c1"># plus 12 hours</span>
<span></span><span class="c1">## array([&#39;1970-01-01T14:01:05&#39;], dtype=&#39;datetime64[s]&#39;)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">d</span><span class="o">-</span><span class="n">dt</span>
<span></span><span class="c1">## array([-2537748065,       -7265,  1640901535], dtype=&#39;timedelta64[s]&#39;)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">numpy.arange</span></code> can be used to generate sequences of equidistant
datetimes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="s2">&quot;1889-08-01&quot;</span><span class="p">,</span> <span class="s2">&quot;2022-01-01&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;datetime64[D]&quot;</span><span class="p">)</span>
<span class="n">dates</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">dates</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>  <span class="c1"># preview</span>
<span></span><span class="c1">## (array([&#39;1889-08-01&#39;, &#39;1889-08-02&#39;, &#39;1889-08-03&#39;], dtype=&#39;datetime64[D]&#39;), array([&#39;2021-12-29&#39;, &#39;2021-12-30&#39;, &#39;2021-12-31&#39;], dtype=&#39;datetime64[D]&#39;))</span>
</pre></div>
</div>
<p>Based on this, we can plot the data for the last 5 years quite easily:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">which</span> <span class="o">=</span> <span class="p">(</span><span class="n">dates</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;2017-01-01&quot;</span><span class="p">))</span>
<span class="n">dates5</span><span class="p">,</span> <span class="n">temps5</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="n">which</span><span class="p">],</span> <span class="n">temps</span><span class="p">[</span><span class="n">which</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dates5</span><span class="p">,</span> <span class="n">temps5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-default" id="id3">
<span id="fig-270-time-uni-14"></span><img alt="../_images/270-time-uni-14-5.png" src="../_images/270-time-uni-14-5.png" />
<p class="caption"><span class="caption-number">Figure 10.3 </span><span class="caption-text">plot of chunk 270-time-uni-14</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="iterative-differences-and-cumulative-sums-revisited">
<h2><span class="section-number">10.2. </span>Iterative Differences and Cumulative Sums Revisited<a class="headerlink" href="#iterative-differences-and-cumulative-sums-revisited" title="Permalink to this headline">¶</a></h2>
<p>Recall the <code class="docutils literal notranslate"><span class="pre">numpy.diff</span></code> function and its almost-inverse, <code class="docutils literal notranslate"><span class="pre">numpy.cumsum</span></code>.
The former can turn a time series into a vector of <em>relative changes</em>
(also called <em>deltas</em>, <span class="math notranslate nohighlight">\(\Delta_i=x_{i+1}-x_i\)</span>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">temps</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span>  <span class="c1"># last 5 days</span>
<span class="n">x</span>
<span></span><span class="c1">## array([ -9.4, -12.8, -12.2, -11.4, -11.4])</span>
</pre></div>
</div>
<p>The iterative differences (deltas) are:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">d</span>
<span></span><span class="c1">## array([-3.4,  0.6,  0.8,  0. ])</span>
</pre></div>
</div>
<p>For instance, between the second and the first day, the midrange temperature
dropped by -3.4°C.</p>
<p>The other way around, the cumulative sums of the deltas:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span></span><span class="c1">## array([-3.4, -2.8, -2. , -2. ])</span>
</pre></div>
</div>
<p>This turned deltas back to a shifted version of the original series.
However, we will need the first (root) observation therefrom
to restore the dataset in full.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span></span><span class="c1">## array([ -9.4, -12.8, -12.2, -11.4, -11.4])</span>
</pre></div>
</div>
<blockquote>
<div><p><strong>Exercise.</strong>
Consider the <a class="reference external" href="https://raw.githubusercontent.com/gagolews/%5Cteaching_data/master/marek/euraud-20200101-20200630-no-na.txt">euraud-20200101-20200630-no-na</a> dataset
which lists daily EUR/AUD exchange rates in the first half of 2020 (remember
COVID-19?), with missing observations removed. Using <code class="docutils literal notranslate"><span class="pre">numpy.diff</span></code>,
compute the minimal, median, average, and maximal daily price <em>changes</em>.
Also, draw a box and whisker plot for these deltas.</p>
</div></blockquote>
</div>
<div class="section" id="smoothing-with-moving-averages">
<h2><span class="section-number">10.3. </span>Smoothing with Moving Averages<a class="headerlink" href="#smoothing-with-moving-averages" title="Permalink to this headline">¶</a></h2>
<p>With time series it makes sense to consider
batches of consecutive points as there is a time dependence between them.
In particular, we can consider computing different
aggregates inside <em>rolling windows</em> of a particular size.</p>
<p>For example, given sequence <span class="math notranslate nohighlight">\((x_1, x_2, \dots, x_n)\)</span>
and some <span class="math notranslate nohighlight">\(k \le n\)</span>, the <span class="math notranslate nohighlight">\(k\)</span>-moving average
is a vector <span class="math notranslate nohighlight">\((y_1, y_2, \dots, y_{n-k+1})\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
y_i = \frac{1}{k} \sum_{j=1}^k x_{i+j-1},
\]</div>
<p>i.e., the arithmetic mean of <span class="math notranslate nohighlight">\(k\)</span> consecutive observations
starting at <span class="math notranslate nohighlight">\(x_i\)</span>.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Here is the 3-moving average:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy.lib.stride_tricks</span> <span class="kn">import</span> <span class="n">sliding_window_view</span>
<span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sliding_window_view</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span></span><span class="c1">## array([4.  , 2.  , 2.33, 4.  , 8.67, 9.  , 6.67])</span>
</pre></div>
</div>
<p>We get, in this order: the mean of the first 3 observations;
the mean of the 2nd, 3rd, and 4th items;
then the mean of the 3rd, 4th, and 5th; and so forth.</p>
<p>And now for something completely different: the 5-moving average:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sliding_window_view</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span></span><span class="c1">## array([3. , 4.2, 5.4, 6. , 7. ])</span>
</pre></div>
</div>
<p>Applying the moving average has the nice effect of
<em>smoothing</em> out all kinds of broadly-conceived noise.
To illustrate this, consider
the temperature data for the 5 last years:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">temps5_ma30</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sliding_window_view</span><span class="p">(</span><span class="n">temps5</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dates5</span><span class="p">[</span><span class="mi">15</span><span class="p">:</span><span class="o">-</span><span class="mi">14</span><span class="p">],</span> <span class="n">temps5_ma30</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;30-day moving average&quot;</span><span class="p">)</span>
<span class="n">temps5_ma100</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sliding_window_view</span><span class="p">(</span><span class="n">temps5</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dates5</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="o">-</span><span class="mi">49</span><span class="p">],</span> <span class="n">temps5_ma100</span><span class="p">,</span> <span class="s2">&quot;r--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;100-day moving average&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-default" id="id4">
<span id="fig-270-time-uni-22"></span><img alt="../_images/270-time-uni-22-7.png" src="../_images/270-time-uni-22-7.png" />
<p class="caption"><span class="caption-number">Figure 10.4 </span><span class="caption-text">plot of chunk 270-time-uni-22</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>Note that computing the moving averages results in a shorter
series, therefore, the corresponding dates needed to be adjusted.
We have centred them by removing a similar number of values
from both sides.
This way, we treat the first 30-day moving average
(the average of the first 30 days) as representative for
the 15th day.</p>
<blockquote>
<div><p><strong>Exercise.</strong> Compute the 1-year and 10-year moving
averages for the complete <code class="docutils literal notranslate"><span class="pre">temps</span></code> dataset.
This will reveal some long-term trends.</p>
</div></blockquote>
<p>Thanks to windowed aggregation, we can be detecting seasonal patterns
(using shortish windows) and general trends (longish windows);
the former can be revealed by subtracting the latter from the original series.</p>
<blockquote>
<div><p><strong>Exercise.</strong> Draw the plot of the 1-year moving average
from which the 10-year average was subtracted.</p>
</div></blockquote>
<p>(*) Also, note that other aggregation functions (such as the median,
min, or max) can be applied in rolling windows too.</p>
<blockquote>
<div><p>(*) <strong>Exercise.</strong> Draw, in the same figure,
the plots of the 1-year moving minimums, medians, and maximums.</p>
</div></blockquote>
<blockquote>
<div><p><strong>Exercise.</strong> Compute the 3-, 5-, and 10-day moving average
averages for the EUR/AUD exchange rates and draw them on a single plot.</p>
</div></blockquote>
</div>
<div class="section" id="a-note-on-nonuniform-sampling">
<h2><span class="section-number">10.4. </span>A Note on Nonuniform Sampling (*)<a class="headerlink" href="#a-note-on-nonuniform-sampling" title="Permalink to this headline">¶</a></h2>
<p>Data do not have to be recorded at equispaced moments in time.
In fact, our EUR/AUD exchange rates are given only on
126 out of 161 days in the first half of 2020.</p>
<blockquote>
<div><p><strong>Exercise.</strong> Load the
<a class="reference external" href="https://raw.githubusercontent.com/gagolews/%5Cteaching_data/master/marek/euraud-20200101-20200630-dates.txt">euraud-20200101-20200630-dates</a>
dataset and plot the currency rates as a function of now nonequidistant
time.</p>
</div></blockquote>
<div class="section" id="dealing-with-nonequispaced-series">
<h3><span class="section-number">10.4.1. </span>Dealing with Nonequispaced Series<a class="headerlink" href="#dealing-with-nonequispaced-series" title="Permalink to this headline">¶</a></h3>
<p>A times series is recorded at unequally spaced points in time
may complicate our analysis.</p>
<p>In some contexts, it might be safe to ignore the real event time
and merely treat them as consecutive samples
(day 1, day 2, day 3, …, day 126).
This approach, however, in some contexts can make the results we obtain
less valid.</p>
<p>If data are generally equispaced but some measurements are not present,
we can add them to our dataset,
mark them as missing values, and use one of the
imputation techniques that we describe in a different part of our course.</p>
<p>Otherwise, we can consider creating
an interpolated version of the original signal
and resampling it
at equally spaced intervals, e.g., using a Fourier method
(<code class="docutils literal notranslate"><span class="pre">scipy.signal.resample</span></code>).</p>
</div>
<div class="section" id="modelling-event-times-with-an-exponential-distribution">
<h3><span class="section-number">10.4.2. </span>Modelling Event Times with an Exponential Distribution (**)<a class="headerlink" href="#modelling-event-times-with-an-exponential-distribution" title="Permalink to this headline">¶</a></h3>
<p>An <a class="reference external" href="https://en.wikipedia.org/wiki/Exponential_distribution">exponential distribution</a> is frequently used
for modelling times between different events (i.e., deltas)
under the assumption that a system generates on average a constant
number of events and that they occur independently of each other.</p>
<p>This may be the case for the times between requests
to a cloud service during peak hours,
wait times for the next pedestrian to appear at a crossing near
the Southern Cross Station in Melbourne, or the amount of time
it takes a bank teller to interact with a customer
(note that there is a whole branch of applied mathematics –
or should we refer to it more fashionably: data science -
called <a class="reference external" href="https://en.wikipedia.org/wiki/Queueing_theory">queuing theory</a>
that deals with this type of modelling).</p>
<p>An exponential family is identified by the scale parameter
<em>s &gt; 0</em>, being at the same time its expected value (but be careful: some
textbooks choose the parameter <em>λ=1/s</em> instead; also
<em>scipy</em> uses this convention).</p>
<p>Here is a pseudorandom sample where there are 5 events per
minute on average:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="n">λ</span> <span class="o">=</span> <span class="mi">60</span><span class="o">/</span><span class="mi">5</span>  <span class="c1"># 5 events per 60 seconds on average</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">expon</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1200</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">λ</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">d</span><span class="p">[:</span><span class="mi">8</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># preview</span>
<span></span><span class="c1">## array([14.307,  4.045,  3.087,  9.617, 15.253,  6.601, 47.412, 13.856])</span>
</pre></div>
</div>
<p>This gave us the wait times between the events (deltas),
in seconds.</p>
<p>A natural sample estimator of the scale parameter is of course:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span></span><span class="c1">## 11.839894504211724</span>
</pre></div>
</div>
<p>Which is close to what we <em>expect</em>, i.e., 12 seconds between
the events.</p>
<p>We can convert the above to datetime
(starting at a fixed calendar date), e.g., as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s2">&quot;2022-01-01T00:00:00&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;datetime64[ms]&quot;</span><span class="p">)</span>
<span class="n">d_ms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># in milliseconds</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">t0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">d_ms</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;timedelta64[ms]&quot;</span><span class="p">)</span>
<span class="n">t</span><span class="p">[:</span><span class="mi">8</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># preview</span>
<span></span><span class="c1">## (array([&#39;2022-01-01T00:00:14.307&#39;, &#39;2022-01-01T00:00:18.352&#39;,</span>
<span class="c1">##        &#39;2022-01-01T00:00:21.439&#39;, &#39;2022-01-01T00:00:31.056&#39;,</span>
<span class="c1">##        &#39;2022-01-01T00:00:46.309&#39;, &#39;2022-01-01T00:00:52.910&#39;,</span>
<span class="c1">##        &#39;2022-01-01T00:01:40.322&#39;, &#39;2022-01-01T00:01:54.178&#39;],</span>
<span class="c1">##       dtype=&#39;datetime64[ms]&#39;), array([&#39;2022-01-01T03:56:45.312&#39;, &#39;2022-01-01T03:56:47.890&#39;],</span>
<span class="c1">##       dtype=&#39;datetime64[ms]&#39;))</span>
</pre></div>
</div>
<p>Note that we converted the deltas to milliseconds so that we didn’t lose
precision; <code class="docutils literal notranslate"><span class="pre">datetime64</span></code> is based on integers, not floating-point numbers.</p>
<p>As an exercise, let’s apply binning and
count how many events occur in each hour:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
    <span class="s2">&quot;2022-01-01T00:00:00&quot;</span><span class="p">,</span> <span class="s2">&quot;2022-01-01T05:00:00&quot;</span><span class="p">,</span>
    <span class="mi">1000</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>  <span class="c1"># number of milliseconds in 1 hour</span>
    <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;datetime64[ms]&quot;</span>
<span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span></span><span class="c1">## (array([305, 300, 274, 321]), array([&#39;2022-01-01T00:00:00.000&#39;, &#39;2022-01-01T01:00:00.000&#39;,</span>
<span class="c1">##        &#39;2022-01-01T02:00:00.000&#39;, &#39;2022-01-01T03:00:00.000&#39;,</span>
<span class="c1">##        &#39;2022-01-01T04:00:00.000&#39;], dtype=&#39;datetime64[ms]&#39;))</span>
</pre></div>
</div>
<p>We expect 5 events per second, hence, 300 of them per hour.
On a side note, from a course in statistics
we know that for exponential inter-event times,
the number of events per unit of time follows a Poisson
distribution.</p>
<blockquote>
<div><p><strong>Exercise.</strong> Consider the <a class="reference external" href="https://raw.githubusercontent.com/gagolews/teaching_data/master/marek/wait_times.txt">wait_times</a> dataset
that gives the times between consecutive events, in seconds.
Estimate the event rate per hour. Draw a histogram representing the number
of events per hour.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="further-reading">
<h2><span class="section-number">10.5. </span>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<p>Note that due to limited spacetime, we merely touched upon the most basic
methods for dealing with time series. The reader is encouraged to take a look
at the broad literature concerning statistical analysis of time series
(e.g., issues in forecasting) as well
as on signal processing (which can be used for the processing of audio);
their toolkits somewhat overlap.</p>
<p>For probabilistic modelling, see textbooks on
stochastic processes.</p>
</div>
<div class="section" id="questions">
<h2><span class="section-number">10.6. </span>Questions<a class="headerlink" href="#questions" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Let’s say we have a time series with <em>n</em> observations.
What is a 1- and an <em>n</em>-moving average?
Which one is smoother, an <em>(0.01n)</em>- or a <em>(0.1n)</em>- one?</p></li>
<li><p>What is the Unix Epoch?</p></li>
<li><p>How can we recreate the original series
when we are given its <code class="docutils literal notranslate"><span class="pre">numpy.diff</span></code>-transformed version?</p></li>
</ol>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="310-matrix.html" class="btn btn-neutral float-right" title="11. Introduction to Matrices in numpy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="260-categorical-uni.html" class="btn btn-neutral float-left" title="9. Handling Categorical Data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2015-2022, Marek Gagolewski. Licensed under CC BY-NC-ND 4.0.
      <span class="lastupdated">
        Last updated on 2022-03-27T18:03:39+1100.
      </span>
    Built with <a href="http://sphinx-doc.org/">Sphinx</a>
    and a customised <a href="https://github.com/rtfd/sphinx_rtd_theme">rtd</a> theme.
    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>