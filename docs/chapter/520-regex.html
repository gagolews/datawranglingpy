<!DOCTYPE html>


<html class="writer-html5" lang="en" >
<!-- Copyright (C) 2020-2021, Marek Gagolewski <https://www.gagolewski.com> -->

<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>19. Regular Expressions (*) &mdash; Minimalist Data Wrangling with Python by Marek Gagolewski</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/proof.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  
    <link rel="canonical" href="https://datawranglingpy.gagolewski.com/chapter/520-regex.html" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/proof.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="20. Outliers, Missing, Censored, and Incorrect Data" href="530-missingness.html" />
    <link rel="prev" title="18. Working with Text Data" href="510-text.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html"> Minimalist Data Wrangling with Python [DRAFTv0.1.1]
          

          
          </a>

          <div class="version">
          by <a style="color: inherit" href="https://www.gagolewski.com">Marek Gagolewski</a>
          </div>

<!--
          
            
            
              <div class="version">
                by Marek Gagolewski
              </div>
            
          
-->

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search phrase..." />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Start Here</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="000-preface.html">Preface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introducing Python</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="110-jupyter.html">1. Getting Started with Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="120-scalar.html">2. Scalar Types in Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="130-sequential.html">3. Sequential and Other Types in Python</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Unidimensional Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="210-vector.html">4. Introduction to Vectors in <strong class="program">numpy</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="220-histogram.html">5. Inspecting the Distribution of Numeric Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="230-aggregate.html">6. Aggregation of Numeric Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="240-transform-uni.html">7. Transforming and Filtering Numeric Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="250-distribution-uni.html">8. 🚧 Continuous Probability Distributions (**)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Multidimensional Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="310-matrix.html">9. Introduction to Matrices in <strong class="program">numpy</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="320-transform-multi.html">10. 🚧 Transforming, Aggregating, and Filtering Multidimensional Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="330-visualise-multi.html">11. 🚧 Visualising Multidimensional Data and Measuring Correlation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Heterogeneous Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="410-dataframe.html">12. 🚧 Introduction to Data Frames in <strong class="program">pandas</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="420-transform-hetero.html">13. 🚧 Basic Operations on Data Frames</a></li>
<li class="toctree-l1"><a class="reference internal" href="430-reshape.html">14. 🚧 Reshaping and Fusing Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="440-categorical.html">15. Handling Categorical Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="450-groupby.html">16. 🚧 Observation Grouping</a></li>
<li class="toctree-l1"><a class="reference internal" href="460-sql.html">17. Database Access</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Text and Other Data</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="510-text.html">18. Working with Text Data</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">19. Regular Expressions (*)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#regex-matching-with-re">19.1. Regex Matching with <strong class="program">re</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#regex-matching-with-pandas">19.2. Regex Matching with <strong class="program">pandas</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#matching-individual-characters">19.3. Matching Individual Characters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#matching-any-character">19.3.1. Matching Any Character</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-character-sets">19.3.2. Defining Character Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complementing-sets">19.3.3. Complementing Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-code-point-ranges">19.3.4. Defining Code Point Ranges</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-predefined-character-sets">19.3.5. Using Predefined Character Sets</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#alternating-and-grouping-subexpressions">19.4. Alternating and Grouping Subexpressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#alternation-operator">19.4.1. Alternation Operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grouping-subexpressions">19.4.2. Grouping Subexpressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-grouping-parentheses">19.4.3. Non-grouping Parentheses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#quantifiers">19.5. Quantifiers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#capture-groups-and-references-thereto">19.6. Capture Groups and References Thereto</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#extracting-capture-group-matches">19.6.1. Extracting Capture Group Matches</a></li>
<li class="toctree-l3"><a class="reference internal" href="#replacing-with-capture-group-matches">19.6.2. Replacing with Capture Group Matches</a></li>
<li class="toctree-l3"><a class="reference internal" href="#back-referencing">19.6.3. Back-Referencing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#anchoring">19.7. Anchoring</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#matching-at-the-beginning-or-end-of-a-string">19.7.1. Matching at the Beginning or End of a String</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matching-at-word-boundaries">19.7.2. Matching at Word Boundaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#looking-behind-and-ahead">19.7.3. Looking Behind and Ahead</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#questions">19.8. Questions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="530-missingness.html">20. Outliers, Missing, Censored, and Incorrect Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="540-time.html">21. Time Series</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="998-changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="999-bibliography.html">Bibliography</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://datawranglingpy.gagolewski.com/datawranglingpy.pdf">This Book in PDF</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/datawranglingpy/blob/master/CODE_OF_CONDUCT.md">Report Bugs or Typos</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/teaching_data">Datasets</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.gagolewski.com">Author</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Minimalist Data Wrangling with Python [DRAFTv0.1.1]</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">19. </span>Regular Expressions (*)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="530-missingness.html" class="btn btn-neutral float-right" title="20. Outliers, Missing, Censored, and Incorrect Data" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      
      
        <a href="510-text.html" class="btn btn-neutral float-left" title="18. Working with Text Data" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="tex2jax_ignore mathjax_ignore section" id="regular-expressions">
<span id="chap-regex"></span><h1><span class="section-number">19. </span>Regular Expressions (*)<a class="headerlink" href="#regular-expressions" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p><em>This is an early draft of</em> Minimalist Data Wrangling with Python <em>by
<a class="reference external" href="https://www.gagolewski.com">Marek Gagolewski</a>. It is distributed
in the hope that it will be useful. Any
<a class="reference external" href="https://github.com/gagolews/datawranglingpy/blob/master/CODE_OF_CONDUCT.md">bug/typos reports/fixes</a>
are appreciated. Although available online, this is a whole course,
and should be read from the beginning to the end. In particular,
refer to the <a class="reference internal" href="000-preface.html#chap-preface"><span class="std std-ref">Preface</span></a> for general introductory remarks.</em></p>
</div></blockquote>
<p>Note that this section contains large excerpts
from yours truly’s other work <span id="id1">[<a class="reference internal" href="999-bibliography.html#id9">Gag22</a>]</span>.</p>
<p><em>Regular expressions (regexes) provide us with a concise grammar for
defining systematic patterns which can be sought in character strings.
Examples of such patterns include: specific fixed substrings, emojis of
any kind, stand-alone sequences of lower-case Latin letters (“words”),
substrings that can be interpreted as real numbers (with or without
fractional parts, also in scientific notation), telephone numbers, email
addresses, or URLs.</em></p>
<p><em>Theoretically, the concept of regular pattern matching dates back to the
so-called regular languages and finite state automata <span id="id2">[<a class="reference internal" href="999-bibliography.html#id14">Kle51</a>]</span>, see
also <span id="id3">[<a class="reference internal" href="999-bibliography.html#id15">RS59</a>]</span> and <span id="id4">[<a class="reference internal" href="999-bibliography.html#id17">HU79</a>]</span>.
Regexes in the form as we know today
have already been present in one of the pre-Unix implementations of the
command-line text editor <strong class="program">qed</strong> <span id="id5">[<a class="reference internal" href="999-bibliography.html#id16">RT70</a>]</span>
(the predecessor of the well-known <strong class="program">sed</strong>).</em></p>
<div class="section" id="regex-matching-with-re">
<h2><span class="section-number">19.1. </span>Regex Matching with <strong class="program">re</strong><a class="headerlink" href="#regex-matching-with-re" title="Permalink to this headline">¶</a></h2>
<p>In Python, the <strong class="program">re</strong> module implements a regular expression matching
engine that accepts patterns following a similar syntax
to the ones available in the Perl language.</p>
<p>Before we proceed with a detailed discussion on how to read and write
regexes, let us first review the methods for identifying the matching
substrings. Below we use the <code class="docutils literal notranslate"><span class="pre">r&quot;\bni+\b&quot;</span></code> regex as an example,
which catches <code class="docutils literal notranslate"><span class="pre">&quot;n&quot;</span></code> followed by at least one <code class="docutils literal notranslate"><span class="pre">&quot;i&quot;</span></code>
that begins and ends at a <em>word boundary</em>, i.e.,
which may be considered standalone words.</p>
<p>In particular, <strong class="command">re.findall</strong> extracts all non-overlapping
matches to a given regex:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;We&#39;re the knights who say ni! niiiii! ni! niiiiiiiii!&quot;</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bni+\b&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;ni&#39;, &#39;niiiii&#39;, &#39;ni&#39;, &#39;niiiiiiiii&#39;]</span>
</pre></div>
</div>
<p>Note that the order of arguments is <em>look for what, where</em>,
not the other way around.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Note that we used the <code class="docutils literal notranslate"><span class="pre">r&quot;...&quot;</span></code> prefix when entering a string
so that <code class="docutils literal notranslate"><span class="pre">\b</span></code> is not treated as a escape sequence
denoting the backspace character. Otherwise, the above would have to be input
as <code class="docutils literal notranslate"><span class="pre">&quot;\\bni+\\b&quot;</span></code>.</p>
</div>
<p>Hadn’t we insisted on matching at the word boundaries (i.e.,
if we used <code class="docutils literal notranslate"><span class="pre">&quot;ni+&quot;</span></code> instead), we would also match the <code class="docutils literal notranslate"><span class="pre">&quot;ni&quot;</span></code> in <code class="docutils literal notranslate"><span class="pre">&quot;knights&quot;</span></code>.</p>
<div style="margin-top: 1em"></div><p>The <strong class="command">re.search</strong> function returns an object of class <code class="docutils literal notranslate"><span class="pre">re.Match</span></code>
that enables us to get some more information about the first match:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bni+\b&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">r</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="c1">## (26, 28, &#39;ni&#39;)</span>
</pre></div>
</div>
<p>The above includes the start and end position (index) and
the match itself. If the regex contains <em>capture groups</em> (see below for
more details), we can also pinpoint the matches thereto.</p>
<div style="margin-top: 1em"></div><p>Moreover, <strong class="command">re.finditer</strong> returns an iterable object that
includes the same details, but now about all the matches:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rs</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bni+\b&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rs</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">((</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">r</span><span class="o">.</span><span class="n">group</span><span class="p">()))</span>
<span class="c1">## (26, 28, &#39;ni&#39;)</span>
<span class="c1">## (30, 36, &#39;niiiii&#39;)</span>
<span class="c1">## (38, 40, &#39;ni&#39;)</span>
<span class="c1">## (42, 52, &#39;niiiiiiiii&#39;)</span>
</pre></div>
</div>
<div style="margin-top: 1em"></div><p><strong class="command">re.split</strong> divides a string into chunks
separated by matches to a given regex:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;!\s+&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&quot;We&#39;re the knights who say ni&quot;, &#39;niiiii&#39;, &#39;ni&#39;, &#39;niiiiiiiii!&#39;]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">r&quot;!\s*&quot;</span></code> regex matches the exclamation mark
followed by one or more whitespace characters.</p>
<div style="margin-top: 1em"></div><p><strong class="command">re.sub</strong> replaces each match with a given string:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bni+\b&quot;</span><span class="p">,</span> <span class="s2">&quot;nu&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## &quot;We&#39;re the knights who say nu! nu! nu! nu!&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>(**) More flexible replacement strings can be generated
by passing a custom function as the second argument:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bni+\b&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;n&quot;</span> <span class="o">+</span> <span class="s2">&quot;u&quot;</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span><span class="o">-</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## &quot;We&#39;re the knights who say nu! nuuuuu! nu! nuuuuuuuuu!&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="regex-matching-with-pandas">
<h2><span class="section-number">19.2. </span>Regex Matching with <strong class="program">pandas</strong><a class="headerlink" href="#regex-matching-with-pandas" title="Permalink to this headline">¶</a></h2>
<p>The <strong class="command">pandas.Series.str</strong> accessor also defines a number
of vectorised functions that utilise the <strong class="program">re</strong> package’s matcher.</p>
<p>Example <code class="docutils literal notranslate"><span class="pre">Series</span></code> object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s2">&quot;display.notebook_repr_html&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>  <span class="c1"># disable &quot;rich&quot; output</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">&quot;ni!&quot;</span><span class="p">,</span> <span class="s2">&quot;niiii, ni, nii!&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;spam, bacon&quot;</span><span class="p">,</span> <span class="s2">&quot;nii, ni!&quot;</span><span class="p">])</span>
<span class="n">x</span>
<span class="c1">## 0                ni!</span>
<span class="c1">## 1    niiii, ni, nii!</span>
<span class="c1">## 2               None</span>
<span class="c1">## 3        spam, bacon</span>
<span class="c1">## 4           nii, ni!</span>
<span class="c1">## dtype: object</span>
</pre></div>
</div>
<p>Here are the most notable functions; their names are
self-explanatory, so let’s just get the picture instead of
the words’ abundance.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bni+\b&quot;</span><span class="p">)</span>
<span class="c1">## 0     True</span>
<span class="c1">## 1     True</span>
<span class="c1">## 2     None</span>
<span class="c1">## 3    False</span>
<span class="c1">## 4     True</span>
<span class="c1">## dtype: object</span>
<span class="n">x</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bni+\b&quot;</span><span class="p">)</span>
<span class="c1">## 0    1.0</span>
<span class="c1">## 1    3.0</span>
<span class="c1">## 2    NaN</span>
<span class="c1">## 3    0.0</span>
<span class="c1">## 4    2.0</span>
<span class="c1">## dtype: float64</span>
<span class="n">x</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bni+\b&quot;</span><span class="p">,</span> <span class="s2">&quot;nu&quot;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1">## 0            nu!</span>
<span class="c1">## 1    nu, nu, nu!</span>
<span class="c1">## 2           None</span>
<span class="c1">## 3    spam, bacon</span>
<span class="c1">## 4        nu, nu!</span>
<span class="c1">## dtype: object</span>
<span class="n">x</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bni+\b&quot;</span><span class="p">)</span>
<span class="c1">## 0                [ni]</span>
<span class="c1">## 1    [niiii, ni, nii]</span>
<span class="c1">## 2                None</span>
<span class="c1">## 3                  []</span>
<span class="c1">## 4           [nii, ni]</span>
<span class="c1">## dtype: object</span>
<span class="n">x</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;,\s+&quot;</span><span class="p">)</span>  <span class="c1"># a comma, one or more whitespaces</span>
<span class="c1">## 0                [ni!]</span>
<span class="c1">## 1    [niiii, ni, nii!]</span>
<span class="c1">## 2                 None</span>
<span class="c1">## 3        [spam, bacon]</span>
<span class="c1">## 4           [nii, ni!]</span>
<span class="c1">## dtype: object</span>
</pre></div>
</div>
<p>In the two last cases, we get lists of strings in result.</p>
<div style="margin-top: 1em"></div><p>Also, later we will mention
<strong class="command">pandas.Series.str.extract</strong> and
<strong class="command">pandas.Series.str.extractall</strong>
which work with regexes that include capture groups.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>(*)
If we intend to seek matches to the same pattern in different strings
without the use of <strong class="program">pandas</strong>,
it might be a good to pre-compile a regex first and
then use the <strong class="command">re.Pattern.findall</strong> method instead or <strong class="command">re.findall</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bni+\b&quot;</span><span class="p">)</span>  <span class="c1"># returns an object of class `re.Pattern`</span>
<span class="n">p</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;We&#39;re the knights who say ni! ni! niiiii! nininiiiiiiiii!&quot;</span><span class="p">)</span>
<span class="c1">## [&#39;ni&#39;, &#39;ni&#39;, &#39;niiiii&#39;]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="matching-individual-characters">
<h2><span class="section-number">19.3. </span>Matching Individual Characters<a class="headerlink" href="#matching-individual-characters" title="Permalink to this headline">¶</a></h2>
<p>Most programming languages and text editors
(including <a class="reference external" href="https://kate-editor.org/"><strong class="program">Kate</strong></a>,
<a class="reference external" href="https://www.eclipse.org/ide/"><strong class="program">Eclipse</strong></a>, and
<a class="reference external" href="https://code.visualstudio.com/"><strong class="program">VSCode</strong></a>) support finding or
replacing patters with regexes. Therefore, they should be amongst the
instruments at every data scientist’s disposal. One general introduction to
regexes is <span id="id6">[<a class="reference internal" href="999-bibliography.html#id13">Fri06</a>]</span>.
The <strong class="program">re</strong> module flavour is summarised
in the official <a class="reference external" href="https://docs.python.org/3/library/re.html">manual</a>,
see also <span id="id7">[<a class="reference internal" href="999-bibliography.html#id18">Kuc22</a>]</span>.
In the following sections we review the most important
elements of the regex syntax as we did in <span id="id8">[<a class="reference internal" href="999-bibliography.html#id9">Gag22</a>]</span>.</p>
<div style="margin-top: 1em"></div><p>We begin by discussing different ways to define character sets. In this
part, determining the length of all matching substrings will be quite
straightforward.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The following characters have special meaning to the regex engine:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">.</span></code>
<code class="docutils literal notranslate"><span class="pre">\</span></code>
<code class="docutils literal notranslate"><span class="pre">|</span></code>
<code class="docutils literal notranslate"><span class="pre">(</span></code>
<code class="docutils literal notranslate"><span class="pre">)</span></code>
<code class="docutils literal notranslate"><span class="pre">[</span></code>
<code class="docutils literal notranslate"><span class="pre">]</span></code>  &gt; <code class="docutils literal notranslate"><span class="pre">{</span></code>
<code class="docutils literal notranslate"><span class="pre">}</span></code>
<code class="docutils literal notranslate"><span class="pre">^</span></code>
<code class="docutils literal notranslate"><span class="pre">$</span></code>
<code class="docutils literal notranslate"><span class="pre">*</span></code>
<code class="docutils literal notranslate"><span class="pre">+</span></code>
<code class="docutils literal notranslate"><span class="pre">?</span></code></p>
</div></blockquote>
</div>
<p>Any regular expression that contains none of
the above behaves like a fixed pattern:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;spam&quot;</span><span class="p">,</span> <span class="s2">&quot;spam, eggs, spam, bacon, sausage, and spam&quot;</span><span class="p">)</span>
<span class="c1">## [&#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;]</span>
</pre></div>
</div>
<p>There are hence 3 occurrences of a pattern that is comprised of 4 code
points, “<code class="docutils literal notranslate"><span class="pre">s</span></code>” followed by “<code class="docutils literal notranslate"><span class="pre">p</span></code>”, then by “<code class="docutils literal notranslate"><span class="pre">a</span></code>”, and ending with “<code class="docutils literal notranslate"><span class="pre">m</span></code>”.</p>
<div style="margin-top: 1em"></div><p>If we wish to include a special character as part of a regular
expression – so that it is treated literally – we’ll need to escape
it with a backslash, “<code class="docutils literal notranslate"><span class="pre">\</span></code>”.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\.&quot;</span><span class="p">,</span> <span class="s2">&quot;spam...&quot;</span><span class="p">)</span>
<span class="c1">## [&#39;.&#39;, &#39;.&#39;, &#39;.&#39;]</span>
</pre></div>
</div>
<div class="section" id="matching-any-character">
<h3><span class="section-number">19.3.1. </span>Matching Any Character<a class="headerlink" href="#matching-any-character" title="Permalink to this headline">¶</a></h3>
<p>The (unescaped) dot, “<code class="docutils literal notranslate"><span class="pre">.</span></code>”, matches any code point except the newline.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;Spam, ham,</span><span class="se">\n</span><span class="s2">jam, SPAM, eggs, and spam&quot;</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;..am&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="c1">## [&#39;Spam&#39;, &#39; ham&#39;, &#39;SPAM&#39;, &#39;spam&#39;]</span>
</pre></div>
</div>
<p>The above matches non-overlapping length-4 substrings that end with
“<code class="docutils literal notranslate"><span class="pre">am</span></code>”, case insensitively.</p>
<p>The dot’s insensitivity to the newline character is motivated by the
need to maintain the compatibility with tools such as <strong class="program">grep</strong> (when
searching within text files in a line-by-line manner). This behaviour
can be altered by setting the <code class="docutils literal notranslate"><span class="pre">DOTALL</span></code> flag.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;..am&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="o">|</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="c1">## [&#39;Spam&#39;, &#39; ham&#39;, &#39;\njam&#39;, &#39;SPAM&#39;, &#39;spam&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="defining-character-sets">
<h3><span class="section-number">19.3.2. </span>Defining Character Sets<a class="headerlink" href="#defining-character-sets" title="Permalink to this headline">¶</a></h3>
<p>Sets of characters can be introduced by enumerating their members within
a pair of square brackets. For instance, “<code class="docutils literal notranslate"><span class="pre">[abc]</span></code>” denotes the set
<em>{a, b, c}</em> – such a regular expression
matches one (and only one) symbol from this set. Moreover, in:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;[hj]am&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;ham&#39;, &#39;jam&#39;]</span>
</pre></div>
</div>
<p>the “<code class="docutils literal notranslate"><span class="pre">[hj]am</span></code>” regex matches: “<code class="docutils literal notranslate"><span class="pre">h</span></code>” or “<code class="docutils literal notranslate"><span class="pre">j</span></code>”, followed by “<code class="docutils literal notranslate"><span class="pre">a</span></code>”,
followed by “<code class="docutils literal notranslate"><span class="pre">m</span></code>”. In other words, <code class="docutils literal notranslate"><span class="pre">&quot;ham&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;jam&quot;</span></code> are the only two
strings that are matched by this pattern (unless matching is done
case-insensitively).</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The following characters, if used within square brackets, may be treated
non-literally:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">\</span></code>
<code class="docutils literal notranslate"><span class="pre">[</span></code>
<code class="docutils literal notranslate"><span class="pre">]</span></code>
<code class="docutils literal notranslate"><span class="pre">^</span></code>
<code class="docutils literal notranslate"><span class="pre">-</span></code>
<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>
<code class="docutils literal notranslate"><span class="pre">~</span></code>
<code class="docutils literal notranslate"><span class="pre">|</span></code></p>
</div></blockquote>
</div>
<p>Therefore, to include them as-is in a character set, the
backslash-escape must be used. For example, “<code class="docutils literal notranslate"><span class="pre">[\[\]\\]</span></code>” matches a
backslash or a square bracket.</p>
</div>
<div class="section" id="complementing-sets">
<h3><span class="section-number">19.3.3. </span>Complementing Sets<a class="headerlink" href="#complementing-sets" title="Permalink to this headline">¶</a></h3>
<p>Including “<code class="docutils literal notranslate"><span class="pre">^</span></code>” after the opening square bracket denotes the set
complement. Hence, “<code class="docutils literal notranslate"><span class="pre">[^abc]</span></code>” matches any code point except “<code class="docutils literal notranslate"><span class="pre">a</span></code>”,
“<code class="docutils literal notranslate"><span class="pre">b</span></code>”, and “<code class="docutils literal notranslate"><span class="pre">c</span></code>”. Here is an example where we seek any substring that
consists of 3 non-spaces.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;Nobody expects the Spanish Inquisition!&quot;</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;[^ ][^ ][^ ]&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;Nob&#39;, &#39;ody&#39;, &#39;exp&#39;, &#39;ect&#39;, &#39;the&#39;, &#39;Spa&#39;, &#39;nis&#39;, &#39;Inq&#39;, &#39;uis&#39;, &#39;iti&#39;, &#39;on!&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="defining-code-point-ranges">
<h3><span class="section-number">19.3.4. </span>Defining Code Point Ranges<a class="headerlink" href="#defining-code-point-ranges" title="Permalink to this headline">¶</a></h3>
<p>Each Unicode code point can be referenced by its unique numeric
identifier for more details. For instance, “<code class="docutils literal notranslate"><span class="pre">a</span></code>” is
assigned code U+0061 and “<code class="docutils literal notranslate"><span class="pre">z</span></code>” is mapped to U+007A. In the pre-Unicode
era (mostly with regards to the ASCII codes, ≤ U+007F, representing
English letters, decimal digits, some punctuation characters, and a few
control characters), we were used to relying on specific code ranges;
e.g., “<code class="docutils literal notranslate"><span class="pre">[a-z]</span></code>” denotes the set comprised of all characters with codes
between U+0061 and U+007A, i.e., lowercase letters of the English
(Latin) alphabet.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;[0-9A-Za-z]&quot;</span><span class="p">,</span> <span class="s2">&quot;Gągolewski&quot;</span><span class="p">)</span>
<span class="c1">## [&#39;G&#39;, &#39;g&#39;, &#39;o&#39;, &#39;l&#39;, &#39;e&#39;, &#39;w&#39;, &#39;s&#39;, &#39;k&#39;, &#39;i&#39;]</span>
</pre></div>
</div>
<p>The above pattern denotes a union of 3 code ranges: digits and ASCII
upper- and lowercase letters.</p>
<p>Nowadays, in the processing of text in natural languages, this notation
should rather be avoided. Note the missing “<code class="docutils literal notranslate"><span class="pre">ą</span></code>” (Polish “<code class="docutils literal notranslate"><span class="pre">a</span></code>” with
ogonek) in the result.</p>
</div>
<div class="section" id="using-predefined-character-sets">
<h3><span class="section-number">19.3.5. </span>Using Predefined Character Sets<a class="headerlink" href="#using-predefined-character-sets" title="Permalink to this headline">¶</a></h3>
<p>Some other noteworthy Unicode-aware code point classes include
the “word characters”:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;aąbßÆAĄB你12𝟛๔٤,.;&#39;! </span><span class="se">\t</span><span class="s2">-+=</span><span class="se">\n</span><span class="s2">[]©←→”„&quot;</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;a&#39;, &#39;ą&#39;, &#39;b&#39;, &#39;ß&#39;, &#39;Æ&#39;, &#39;A&#39;, &#39;Ą&#39;, &#39;B&#39;, &#39;你&#39;, &#39;1&#39;, &#39;2&#39;, &#39;𝟛&#39;, &#39;๔&#39;, &#39;٤&#39;]</span>
</pre></div>
</div>
<p>decimal digits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;1&#39;, &#39;2&#39;, &#39;𝟛&#39;, &#39;๔&#39;, &#39;٤&#39;]</span>
</pre></div>
</div>
<p>and whitespaces:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39; &#39;, &#39;\t&#39;, &#39;\n&#39;]</span>
</pre></div>
</div>
<p>Moreover, e.g., “<code class="docutils literal notranslate"><span class="pre">\W</span></code>” is
equivalent to “<code class="docutils literal notranslate"><span class="pre">[^\w]</span></code>” , i.e.,
denotes its complement.</p>
</div>
</div>
<div class="section" id="alternating-and-grouping-subexpressions">
<h2><span class="section-number">19.4. </span>Alternating and Grouping Subexpressions<a class="headerlink" href="#alternating-and-grouping-subexpressions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="alternation-operator">
<h3><span class="section-number">19.4.1. </span>Alternation Operator<a class="headerlink" href="#alternation-operator" title="Permalink to this headline">¶</a></h3>
<p>The alternation operator, “<code class="docutils literal notranslate"><span class="pre">|</span></code>”, matches either its left or its right
branch, for instance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;spam, egg, ham, jam, algae, and an amalgam of spam, all al dente&quot;</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;spam|ham&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;spam&#39;, &#39;ham&#39;, &#39;spam&#39;]</span>
</pre></div>
</div>
<p>“<code class="docutils literal notranslate"><span class="pre">|</span></code>” has a very low precedence. Therefore, if we wish to introduce an
alternative of subexpressions, we need to group them
using the “<code class="docutils literal notranslate"><span class="pre">(?:...)</span></code>” syntax. For instance, “<code class="docutils literal notranslate"><span class="pre">(?:sp|h)am</span></code>” matches either “<code class="docutils literal notranslate"><span class="pre">spam</span></code>”
or “<code class="docutils literal notranslate"><span class="pre">ham</span></code>”.</p>
<p>Note that the bare use of the round brackets, <code class="docutils literal notranslate"><span class="pre">&quot;(...)&quot;</span></code>
(i.e., without the <code class="docutils literal notranslate"><span class="pre">&quot;?:&quot;</span></code>) part, has the side-effect of creating new
capturing groups, see below for more details.</p>
</div>
<div class="section" id="grouping-subexpressions">
<h3><span class="section-number">19.4.2. </span>Grouping Subexpressions<a class="headerlink" href="#grouping-subexpressions" title="Permalink to this headline">¶</a></h3>
<p>Also, matching is always done left-to-right, on a first-come,
first-served basis. So, if the left branch is a subset of the right
one, the latter will never be matched. In particular,
“<code class="docutils literal notranslate"><span class="pre">(?:al|alga|algae)</span></code>” can only match “<code class="docutils literal notranslate"><span class="pre">al</span></code>”. To fix this, we can write
“<code class="docutils literal notranslate"><span class="pre">(?:algae|alga|al)</span></code>”.</p>
</div>
<div class="section" id="non-grouping-parentheses">
<h3><span class="section-number">19.4.3. </span>Non-grouping Parentheses<a class="headerlink" href="#non-grouping-parentheses" title="Permalink to this headline">¶</a></h3>
<p>Some parenthesised subexpressions – those in which the opening bracket
is followed by the question mark – have a distinct meaning. In
particular, “<code class="docutils literal notranslate"><span class="pre">(?#...)</span></code>” denotes a free-format comment that is ignored by
the regex parser:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span>
  <span class="s2">&quot;(?# match &#39;sp&#39; or &#39;h&#39;)(?:sp|h)(?# and &#39;am&#39;)am|(?# or match &#39;egg&#39;)egg&quot;</span><span class="p">,</span>
  <span class="n">x</span>
<span class="p">)</span>
<span class="c1">## [&#39;spam&#39;, &#39;egg&#39;, &#39;ham&#39;, &#39;spam&#39;]</span>
</pre></div>
</div>
<p>This is just horrible. Luckily,
constructing more sophisticated regexes by concatenating
subfragments thereof is more readable:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span>
       <span class="s2">&quot;(?:sp|h)&quot;</span> <span class="o">+</span>   <span class="c1"># match either &#39;sp&#39; or &#39;h&#39;</span>
       <span class="s2">&quot;am&quot;</span> <span class="o">+</span>         <span class="c1"># followed by &#39;am&#39;</span>
    <span class="s2">&quot;|&quot;</span> <span class="o">+</span>        <span class="c1"># ... or ...</span>
       <span class="s2">&quot;egg&quot;</span><span class="p">,</span>         <span class="c1"># just match &#39;egg&#39;</span>
    <span class="n">x</span>
<span class="p">)</span>
<span class="c1">## [&#39;spam&#39;, &#39;egg&#39;, &#39;ham&#39;, &#39;spam&#39;]</span>
</pre></div>
</div>
<p>What is more, e.g., “<code class="docutils literal notranslate"><span class="pre">(?i)</span></code>” enables the case-insensitive mode.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;(?i)spam&quot;</span><span class="p">,</span> <span class="s2">&quot;Spam spam SPAMITY spAm&quot;</span><span class="p">)</span>
<span class="c1">## [&#39;Spam&#39;, &#39;spam&#39;, &#39;SPAM&#39;, &#39;spAm&#39;]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="quantifiers">
<h2><span class="section-number">19.5. </span>Quantifiers<a class="headerlink" href="#quantifiers" title="Permalink to this headline">¶</a></h2>
<p>More often than not, a variable number of instances of the same
subexpression needs to be captured or its presence should be made
optional. This can be achieved by means of the following quantifiers:</p>
<ul class="simple">
<li><p>“<code class="docutils literal notranslate"><span class="pre">?</span></code>” matches 0 or 1 times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">*</span></code>” matches 0 or more times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">+</span></code>” matches 1 or more times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">{n,m}</span></code>” matches between <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">m</span></code> times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">{n,}</span></code>” matches at least <code class="docutils literal notranslate"><span class="pre">n</span></code> times;</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">{n}</span></code>” matches exactly <code class="docutils literal notranslate"><span class="pre">n</span></code> times.</p></li>
</ul>
<p>These operators are applied onto the directly preceding atoms.
For example, “<code class="docutils literal notranslate"><span class="pre">ba+</span></code>”
captures <code class="docutils literal notranslate"><span class="pre">&quot;ba&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;baa&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;baaa&quot;</span></code>, etc., but neither <code class="docutils literal notranslate"><span class="pre">&quot;b&quot;</span></code> alone
nor <code class="docutils literal notranslate"><span class="pre">&quot;bababa&quot;</span></code> altogether.</p>
<p>By default, the quantifiers are greedy – they match the repeated
subexpression as many times as possible. The “<code class="docutils literal notranslate"><span class="pre">?</span></code>” suffix (hence,
quantifiers such as “<code class="docutils literal notranslate"><span class="pre">??</span></code>”, “<code class="docutils literal notranslate"><span class="pre">*?</span></code>”, “<code class="docutils literal notranslate"><span class="pre">+?</span></code>”, and so forth) tries with as
few occurrences as possible (to obtain a match still).</p>
<div style="margin-top: 1em"></div><p>Greedy:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;sp(AM)(maps)(SP)am&quot;</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\(.+\)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;(AM)(maps)(SP)&#39;]</span>
</pre></div>
</div>
<p>Lazy:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\(.+?\)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;(AM)&#39;, &#39;(maps)&#39;, &#39;(SP)&#39;]</span>
</pre></div>
</div>
<p>Greedy (but clever):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\([^)]+\)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;(AM)&#39;, &#39;(maps)&#39;, &#39;(SP)&#39;]</span>
</pre></div>
</div>
<p>The first regex is greedy: it matches an opening bracket, then as many
characters as possible (including “<code class="docutils literal notranslate"><span class="pre">)</span></code>”) that are followed by a closing
bracket. The two other patterns terminate as soon as the first closing
bracket is found.</p>
<div style="margin-top: 1em"></div><p>More examples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;spamamamnomnomnomammmmmmmmm&quot;</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;sp(?:am|nom)+&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;spamamamnomnomnomam&#39;]</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;sp(?:am|nom)+?&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;spam&#39;]</span>
</pre></div>
</div>
<p>And:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;sp(?:am|nom)+?m*&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;spam&#39;]</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;sp(?:am|nom)+?m+&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;spamamamnomnomnomammmmmmmmm&#39;]</span>
</pre></div>
</div>
<div style="margin-top: 1em"></div><p>Let’s stress that the quantifier is applied to the subexpression that
stands directly before it. Grouping parentheses can be used in case they
are needed.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;12, 34.5, 678.901234, 37...629, ...&quot;</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+\.\d+&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;34.5&#39;, &#39;678.901234&#39;]</span>
</pre></div>
</div>
<p>matches digits, a dot, and another series of
digits.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+(?:\.\d+)?&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;12&#39;, &#39;34.5&#39;, &#39;678.901234&#39;, &#39;37&#39;, &#39;629&#39;]</span>
</pre></div>
</div>
<p>finds digits which are possibly (but not
necessarily) followed by a dot and a digit sequence.</p>
<div class="proof proof-type-exercise" id="id9">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.1</span>
        
    </div><div class="proof-content">
<p>Write a regex that extracts all #hashtags
from a string #omg #SoEasy.</p>
</div></div></div>
<div class="section" id="capture-groups-and-references-thereto">
<h2><span class="section-number">19.6. </span>Capture Groups and References Thereto<a class="headerlink" href="#capture-groups-and-references-thereto" title="Permalink to this headline">¶</a></h2>
<p>Round-bracketed subexpressions (without the <code class="docutils literal notranslate"><span class="pre">&quot;?:&quot;</span></code> prefix)
form the so-called <em>capture groups</em> that can be extracted separately or be
referred to in other parts of the same regex.</p>
<div class="section" id="extracting-capture-group-matches">
<h3><span class="section-number">19.6.1. </span>Extracting Capture Group Matches<a class="headerlink" href="#extracting-capture-group-matches" title="Permalink to this headline">¶</a></h3>
<p>The above is evident when we use <strong class="command">re.findall</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;name=&#39;Sir Launcelot&#39;, quest=&#39;Seek the Grail&#39;, favecolour=&#39;blue&#39;&quot;</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+)=&#39;(.+?)&#39;&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [(&#39;name&#39;, &#39;Sir Launcelot&#39;), (&#39;quest&#39;, &#39;Seek the Grail&#39;), (&#39;favecolour&#39;, &#39;blue&#39;)]</span>
</pre></div>
</div>
<p>Simply returned the matches to the capture groups, not the whole matching
substring.</p>
<p><strong class="command">re.find</strong> and <strong class="command">re.finditer</strong> can pinpoint each component:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+)=&#39;(.+?)&#39;&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;all (0):&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">r</span><span class="o">.</span><span class="n">group</span><span class="p">()))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     1 :&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">r</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     2 :&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">r</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
<span class="c1">## all (0): (0, 20, &quot;name=&#39;Sir Launcelot&#39;&quot;)</span>
<span class="c1">##      1 : (0, 4, &#39;name&#39;)</span>
<span class="c1">##      2 : (6, 19, &#39;Sir Launcelot&#39;)</span>
</pre></div>
</div>
<p>Here is a vectorised version  of the above from <strong class="program">pandas</strong>,
returning the first match:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span>
    <span class="s2">&quot;name=&#39;Sir Launcelot&#39;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;quest=&#39;Seek the Grail&#39;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;favecolour=&#39;blue&#39;, favecolour=&#39;yel.. Aaargh!&#39;&quot;</span>
<span class="p">])</span>
<span class="n">y</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+)=&#39;(.+?)&#39;&quot;</span><span class="p">)</span>
<span class="c1">##             0               1</span>
<span class="c1">## 0        name   Sir Launcelot</span>
<span class="c1">## 1       quest  Seek the Grail</span>
<span class="c1">## 2  favecolour            blue</span>
</pre></div>
</div>
<p>We see that the findings are presented in a data frame form.
The first column gives the matches to the first
capture group, and so forth.</p>
<p>All matches are available too:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extractall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+)=&#39;(.+?)&#39;&quot;</span><span class="p">)</span>
<span class="c1">##                   0               1</span>
<span class="c1">##   match                            </span>
<span class="c1">## 0 0            name   Sir Launcelot</span>
<span class="c1">## 1 0           quest  Seek the Grail</span>
<span class="c1">## 2 0      favecolour            blue</span>
<span class="c1">##   1      favecolour   yel.. Aaargh!</span>
</pre></div>
</div>
<div style="margin-top: 1em"></div><p>Recall that if we just need the grouping part of “<code class="docutils literal notranslate"><span class="pre">(...)</span></code>”, i.e., without the
capturing feature, “<code class="docutils literal notranslate"><span class="pre">(?:...)</span></code>” can be applied.</p>
<div style="margin-top: 1em"></div><p>Also, named capture
groups defined like “<code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>” are supported.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="s2">&quot;(?:</span><span class="se">\\</span><span class="s2">w+)=&#39;(?P&lt;value&gt;.+?)&#39;&quot;</span><span class="p">)</span>
<span class="c1">##             value</span>
<span class="c1">## 0   Sir Launcelot</span>
<span class="c1">## 1  Seek the Grail</span>
<span class="c1">## 2            blue</span>
</pre></div>
</div>
</div>
<div class="section" id="replacing-with-capture-group-matches">
<h3><span class="section-number">19.6.2. </span>Replacing with Capture Group Matches<a class="headerlink" href="#replacing-with-capture-group-matches" title="Permalink to this headline">¶</a></h3>
<p>Matches to particular capture groups can be recalled in replacement
strings when using <strong class="command">re.sub</strong> and <strong class="command">pandas.Series.str.replace</strong>.
Here, the match in its entirety is
denoted with “<code class="docutils literal notranslate"><span class="pre">\g&lt;0&gt;</span></code>”, then “<code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code>” stores whatever was caught by the first
capture group, “<code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;</span></code>” is the match to the second capture group, etc.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+)=&#39;(.+?)&#39;&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\g&lt;2&gt; is a \g&lt;1&gt;&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## &#39;Sir Launcelot is a name, Seek the Grail is a quest, blue is a favecolour&#39;</span>
</pre></div>
</div>
<p>Named capture groups can be referred to too:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;key&gt;\w+)=&#39;(?P&lt;value&gt;.+?)&#39;&quot;</span><span class="p">,</span>
  <span class="sa">r</span><span class="s2">&quot;\g&lt;value&gt; is a \g&lt;key&gt;&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## &#39;Sir Launcelot is a name, Seek the Grail is a quest, blue is a favecolour&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="back-referencing">
<h3><span class="section-number">19.6.3. </span>Back-Referencing<a class="headerlink" href="#back-referencing" title="Permalink to this headline">¶</a></h3>
<p>Matches to capture groups can also be part of the regexes themselves.
For example, “<code class="docutils literal notranslate"><span class="pre">\1</span></code>” denotes whatever has been consumed by the first
capture group.</p>
<p>Even though, in general, parsing HTML code with regexes is not
recommended, let’s consider the following examples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;&lt;strong&gt;&lt;em&gt;spam&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;eggs&lt;/code&gt;&quot;</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&lt;[a-z]+&gt;.*?&lt;/[a-z]+&gt;&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;&lt;strong&gt;&lt;em&gt;spam&lt;/em&gt;&#39;, &#39;&lt;code&gt;eggs&lt;/code&gt;&#39;]</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(&lt;([a-z]+)&gt;.*?&lt;/\2&gt;)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [(&#39;&lt;strong&gt;&lt;em&gt;spam&lt;/em&gt;&lt;/strong&gt;&#39;, &#39;strong&#39;), (&#39;&lt;code&gt;eggs&lt;/code&gt;&#39;, &#39;code&#39;)]</span>
</pre></div>
</div>
<p>The second regex guarantees that the match will include all characters
between the opening <code class="docutils literal notranslate"><span class="pre">&lt;tag&gt;</span></code> and the corresponding (not: any) closing
<code class="docutils literal notranslate"><span class="pre">&lt;/tag&gt;</span></code>. Named capture groups can be referenced using the <code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code>
syntax (the angle brackets are part of the token):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(&lt;(?P&lt;tagname&gt;[a-z]+)&gt;.*?&lt;/(?P=tagname)&gt;)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [(&#39;&lt;strong&gt;&lt;em&gt;spam&lt;/em&gt;&lt;/strong&gt;&#39;, &#39;strong&#39;), (&#39;&lt;code&gt;eggs&lt;/code&gt;&#39;, &#39;code&#39;)]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="anchoring">
<h2><span class="section-number">19.7. </span>Anchoring<a class="headerlink" href="#anchoring" title="Permalink to this headline">¶</a></h2>
<p>Lastly, let’s mention the ways to match a pattern at a given abstract
position within a string.</p>
<div class="section" id="matching-at-the-beginning-or-end-of-a-string">
<h3><span class="section-number">19.7.1. </span>Matching at the Beginning or End of a String<a class="headerlink" href="#matching-at-the-beginning-or-end-of-a-string" title="Permalink to this headline">¶</a></h3>
<p>“<code class="docutils literal notranslate"><span class="pre">^</span></code>” and “<code class="docutils literal notranslate"><span class="pre">$</span></code>” match, respectively, start and end of the string
(or each line within a string, if the <code class="docutils literal notranslate"><span class="pre">re.MULTILINE</span></code> flag is set).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">&quot;spam egg&quot;</span><span class="p">,</span> <span class="s2">&quot;bacon spam&quot;</span><span class="p">,</span> <span class="s2">&quot;spam&quot;</span><span class="p">,</span> <span class="s2">&quot;egg spam bacon&quot;</span><span class="p">,</span> <span class="s2">&quot;sausage&quot;</span><span class="p">])</span>
<span class="n">rs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;spam&quot;</span><span class="p">,</span> <span class="s2">&quot;^spam&quot;</span><span class="p">,</span> <span class="s2">&quot;spam$&quot;</span><span class="p">,</span> <span class="s2">&quot;spam$|^spam&quot;</span><span class="p">,</span> <span class="s2">&quot;^spam$&quot;</span><span class="p">]</span>
<span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">rs</span><span class="p">)</span>
<span class="c1">##     spam  ^spam  spam$  spam$|^spam  ^spam$</span>
<span class="c1">## 0   True   True  False         True   False</span>
<span class="c1">## 1   True  False   True         True   False</span>
<span class="c1">## 2   True   True   True         True    True</span>
<span class="c1">## 3   True  False  False        False   False</span>
<span class="c1">## 4  False  False  False        False   False</span>
</pre></div>
</div>
<p>The 5 regular expressions match “<code class="docutils literal notranslate"><span class="pre">spam</span></code>”, respectively, anywhere within
the string, at the beginning, at the end, at the beginning or end, and
in strings that are equal to the pattern itself.</p>
<div class="proof proof-type-exercise" id="id10">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.2</span>
        
    </div><div class="proof-content">
<p>Write a regex that does the same job as <strong class="command">str.strip</strong>.</p>
</div></div></div>
<div class="section" id="matching-at-word-boundaries">
<h3><span class="section-number">19.7.2. </span>Matching at Word Boundaries<a class="headerlink" href="#matching-at-word-boundaries" title="Permalink to this headline">¶</a></h3>
<p>Furthermore, “<code class="docutils literal notranslate"><span class="pre">\b</span></code>” matches at a “word boundary”, e.g., near spaces,
punctuation marks, or at the start/end of a string (i.e., wherever there
is a transition between a word, “<code class="docutils literal notranslate"><span class="pre">\w</span></code>”, and a non-word character,
“<code class="docutils literal notranslate"><span class="pre">\W</span></code>”, or vice versa).</p>
<p>In the following example, we match all stand-alone numbers
(this regular expression is provided for didactic purposes only):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[-+]?\b\d+(?:\.\d+)?\b&quot;</span><span class="p">,</span> <span class="s2">&quot;+12, 34.5, -5.3243&quot;</span><span class="p">)</span>
<span class="c1">## [&#39;+12&#39;, &#39;34.5&#39;, &#39;-5.3243&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="looking-behind-and-ahead">
<h3><span class="section-number">19.7.3. </span>Looking Behind and Ahead<a class="headerlink" href="#looking-behind-and-ahead" title="Permalink to this headline">¶</a></h3>
<p>There are also ways to guarantee that a pattern occurrence begins or
ends with a match to some subexpression: “<code class="docutils literal notranslate"><span class="pre">(?&lt;=...)...</span></code>” is the
so-called look-behind, whereas “<code class="docutils literal notranslate"><span class="pre">...(?=...)</span></code>” denotes the look-ahead.
Moreover, “<code class="docutils literal notranslate"><span class="pre">(?&lt;!...)...</span></code>” and “<code class="docutils literal notranslate"><span class="pre">...(?!...)</span></code>” are their negated
(“negative look-behind/ahead”) versions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;I like spam, spam, eggs, and spam.&quot;</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\b\w+\b(?=[,.])&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;spam&#39;, &#39;spam&#39;, &#39;eggs&#39;, &#39;spam&#39;]</span>
<span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\b\w+\b(?![,.])&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">## [&#39;I&#39;, &#39;like&#39;, &#39;and&#39;]</span>
</pre></div>
</div>
<p>The first regex captures words that end with “<code class="docutils literal notranslate"><span class="pre">,</span></code>” or “<code class="docutils literal notranslate"><span class="pre">.</span></code>”. The second
one matches words that end neither with “<code class="docutils literal notranslate"><span class="pre">,</span></code>” nor “<code class="docutils literal notranslate"><span class="pre">.</span></code>”.</p>
<div class="proof proof-type-exercise" id="id11">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.3</span>
        
    </div><div class="proof-content">
<p>Write a regex that extracts
all standalone numbers accepted by Python,
including <code class="docutils literal notranslate"><span class="pre">12.123</span></code>, <code class="docutils literal notranslate"><span class="pre">-53</span></code>, <code class="docutils literal notranslate"><span class="pre">+1e-9</span></code>,
<code class="docutils literal notranslate"><span class="pre">-1.2423e10</span></code>, <code class="docutils literal notranslate"><span class="pre">4.</span></code> and <code class="docutils literal notranslate"><span class="pre">.2</span></code>.</p>
</div></div><div class="proof proof-type-exercise" id="id12">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.4</span>
        
    </div><div class="proof-content">
<p>Write a regex that matches all email addresses.</p>
</div></div><div class="proof proof-type-exercise" id="id13">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.5</span>
        
    </div><div class="proof-content">
<p>Write a regex that matches all URLs
starting with <code class="docutils literal notranslate"><span class="pre">http://</span></code> or <code class="docutils literal notranslate"><span class="pre">https://</span></code>.</p>
</div></div><div class="proof proof-type-exercise" id="id14">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.6</span>
        
    </div><div class="proof-content">
<p>Cleanse the
<a class="reference external" href="https://github.com/gagolews/teaching_data/blob/master/marek/warsaw_weather.csv"><code class="docutils literal notranslate"><span class="pre">warsaw_weather</span></code></a>
dataset so that it contains analysable numeric data.</p>
</div></div></div>
</div>
<div class="section" id="questions">
<h2><span class="section-number">19.8. </span>Questions<a class="headerlink" href="#questions" title="Permalink to this headline">¶</a></h2>
<div class="proof proof-type-exercise" id="id15">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.7</span>
        
    </div><div class="proof-content">
<p>What are the problems with the <code class="docutils literal notranslate"><span class="pre">&quot;[A-Za-z]&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;[A-z]&quot;</span></code> character sets?</p>
</div></div><div class="proof proof-type-exercise" id="id16">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.8</span>
        
    </div><div class="proof-content">
<p>Name the two ways to turn on case-insensitive regex matching.</p>
</div></div><div class="proof proof-type-exercise" id="id17">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.9</span>
        
    </div><div class="proof-content">
<p>What is a word boundary?</p>
</div></div><div class="proof proof-type-exercise" id="id18">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.10</span>
        
    </div><div class="proof-content">
<p>What is the difference between the <code class="docutils literal notranslate"><span class="pre">&quot;^&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;$&quot;</span></code> anchors?</p>
</div></div><div class="proof proof-type-exercise" id="id19">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.11</span>
        
    </div><div class="proof-content">
<p>When we would prefer using <code class="docutils literal notranslate"><span class="pre">&quot;[0-9]&quot;</span></code> instead of <code class="docutils literal notranslate"><span class="pre">&quot;\d&quot;</span></code>?</p>
</div></div><div class="proof proof-type-exercise" id="id20">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.12</span>
        
    </div><div class="proof-content">
<p>What is the difference between the <code class="docutils literal notranslate"><span class="pre">&quot;?&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;??&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;*&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;*?&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;+&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&quot;+?&quot;</span></code> quantifiers?</p>
</div></div><div class="proof proof-type-exercise" id="id21">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.13</span>
        
    </div><div class="proof-content">
<p>Does <code class="docutils literal notranslate"><span class="pre">&quot;.&quot;</span></code> match all the characters?</p>
</div></div><div class="proof proof-type-exercise" id="id22">

    <div class="proof-title">
        <span class="proof-type">Exercise 19.14</span>
        
    </div><div class="proof-content">
<p>What are named capture groups and how to refer to the matches
thereto in <strong class="command">re.sub</strong>?</p>
</div></div></div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="530-missingness.html" class="btn btn-neutral float-right" title="20. Outliers, Missing, Censored, and Incorrect Data" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="510-text.html" class="btn btn-neutral float-left" title="18. Working with Text Data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Marek Gagolewski. Licensed under CC BY-NC-ND 4.0.
      <span class="lastupdated">
        Last updated on 2022-04-01T15:41:11+1100.
      </span>
    Built with <a href="http://sphinx-doc.org/">Sphinx</a>
    and a customised <a href="https://github.com/rtfd/sphinx_rtd_theme">rtd</a> theme.
    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>